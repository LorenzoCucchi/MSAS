#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Assignment
 Dymola Version 2023 (64-bit), 2022-04-13 translated this at Sat Dec  2 13:30:00 2023

   */

#include <matrixop.h>
#include "matrixop.c"
static double DymArrays1[5]={0.0, 1.0, 1.0, 0.0, 0.0};
#if defined(DynSimStruct)
static double DymArrays0[7]={3.0, 2.0, 1.0, 0.0, -1.0, 1.0, 1.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
DYMOLA_STATIC int   Modelica_Math_Matrices_isEqual(RealArray   M10_0, RealArray  
   M20_0, double  eps0_0);
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Math.Matrices.isEqual
discrete input Real M1[:, :] "First matrix";
discrete input Real M2[:, :] "Second matrix (may have different size as M1)";
discrete input Real eps(start = 0, min = 0.0) "Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) <= eps";
output Boolean result "= true, if matrices have the same size and the same elements";
protected 
Integer nrow(start = size(M1, 1)) "Number of rows of matrix M1";
Integer ncol(start = size(M1, 2)) "Number of columns of matrix M1";
Integer i(start = 1);
Integer j;
public 
algorithm 
result := false;
if (size(M2, 1) == nrow and size(M2, 2) == ncol) then 
result := true;
while i <= nrow loop
j := 1;
while j <= ncol loop
if (abs(M1[i, j]-M2[i, j]) > eps) then 
result := false;
i := nrow;
j := ncol;
end if;
j := j+1;
end while;
i := i+1;
end while;
end if;
end Modelica.Math.Matrices.isEqual;

  */
DYMOLA_STATIC int   Modelica_Math_Matrices_isEqual(RealArray   M10_0, RealArray  
   M20_0, double  eps0_0) {
  PushContext("Modelica.Math.Matrices.isEqual")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nrow0_0;
    int   ncol0_0;
    int   i0_0;
    int   j0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    nrow0_0 = DYNSizeSimple(M10_0, 1);
    ncol0_0 = DYNSizeSimple(M10_0, 2);
    i0_0 = 1;
    j0_0=0;
    /* Start of real code */
      result0_0 = false;
      if (DYNSizeSimple(M20_0, 1) == nrow0_0 AND DYNSizeSimple(M20_0, 2) == 
        ncol0_0) {
        result0_0 = true;
        while (i0_0 <= nrow0_0) {
          j0_0 = 1;
          while (j0_0 <= ncol0_0) {
            if (fabs(RealElement( M10_0, (SizeType)(i0_0), (SizeType)(j0_0))-
              RealElement( M20_0, (SizeType)(i0_0), (SizeType)(j0_0))) > eps0_0)
               {
              result0_0 = false;
              i0_0 = nrow0_0;
              j0_0 = ncol0_0;
            }
            j0_0 = j0_0+1;
          }
          i0_0 = i0_0+1;
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#define NX_    7
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    130
#define NWP_   69
#define NP_    46
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 1838240076
#define NHash2_ -1139982699
#define NHash3_ 0
#define NI_    0
#define NRelF_ 12
#define NRel_  12
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    95
#define SizePre_ 1
#define SizeEq_ 7
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 48
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Assignment";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[14]={4 , 3 , 1 , 2 , 7 , 2 , 3 , 6 , 1 , 4 , 1 , 5
   , 0 , 0};
static int QJacobianGrp0[7]={1, 1 , 3 , 1 , 4 , 7 , 0};
static int QJacobianGrp1[8]={6, 0, 0, 3, 3, 0, 3, 0};
static int QJacobianGrp2[8]={4, 0, 4, 4, 4, 0, 4, 0};
static int QJacobianGrp3[8]={5, 5, 0, 5, 5, 5, 5, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[5]={
{1, QJacobianGrp0},{0, QJacobianGrp1},{0, QJacobianGrp2},{0, QJacobianGrp3},
  {0,0}};
DYMOLA_STATIC double QJacobianCD_[8]={0  , 44 , 55 , 60 , 63 , 64 , 90 , 110};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,89) = 288.15;
DYNX(W_,69) = true;
DYNX(W_,70) = false;
DYNX(W_,71) = false;
DYNX(W_,72) = false;
DYNX(W_,73) = 2;
DYNX(F_,3) = 0;
DYNX(F_,4) = 0;
DYNX(F_,6) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,2) = false;
DYNX(W_,5) = false;
DYNX(W_,7) = 3;
DYNX(W_,10) = false;
DYNX(W_,12) = 4;
DYNX(W_,13) = true;
DYNX(W_,16) = true;
DYNX(W_,38) = true;
memcpy(&DYNX(W_,40), &DymArrays0, sizeof(double)*7);
DYNX(W_,56) = 0.0001;
DYNX(W_,57) = 4;
DYNX(W_,58) = true;
DYNX(W_,61) = 1E-10;
DYNX(W_,62) = 3;
DYNX(W_,63) = false;
DYNX(W_,14) = 293.15;
DYNX(W_,55) = 0;
DYNX(W_,66) = 3;
DYNX(W_,67) = false;
DYNX(W_,68) = 2;
DYNX(W_,65) = false;
DYNX(W_,64) = 0;
DYNX(W_,9) = 0;
DYNX(W_,6) = 0;
DYNX(W_,0) = 0;
DYNX(W_,15) = 0.0;
DYNX(W_,11) = 0.0;
DYNX(W_,1) = 0.0;
DYNX(W_,8) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,44) >= DYNX(DP_,45),"limiter.uMax >= limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,44), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,45),
   true, 0)),")"));
BoundParameterSection
DYNX(W_,3) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,3)-DYNX(DP_,1)) >= 1E-15,"1+resistor.alpha*(resistor.T_heatPort-resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,17) = DYNX(DP_,8);
AssertModelica(fabs(DYNX(W_,17)) > 0,"abs(gearbox.lossyGear.ratio) > 0", 
  "Error in initialization of LossyGear: ratio may not be zero");
DYNX(W_,18) = DYNX(DP_,9);
DYNX(W_,19) = DYNX(DP_,10);
DYNX(W_,20) = DYNX(DP_,11);
DYNX(W_,21) = DYNX(DP_,12);
DYNX(W_,22) = DYNX(DP_,13);
DYNX(W_,23) = DYNX(DP_,14);
DYNX(W_,24) = DYNX(DP_,15);
DYNX(W_,25) = DYNX(DP_,16);
DYNX(W_,26) = DYNX(DP_,17);
DYNX(W_,27) = DYNX(DP_,18);
DYNX(W_,28) = DYNX(DP_,19);
DYNX(W_,29) = DYNX(DP_,20);
DYNX(W_,30) = DYNX(DP_,21);
DYNX(W_,31) = DYNX(DP_,22);
DYNX(W_,32) = DYNX(DP_,23);
DYNX(W_,33) = DYNX(DP_,24);
DYNX(W_,34) = DYNX(DP_,25);
DYNX(W_,35) = DYNX(DP_,26);
DYNX(W_,36) = DYNX(DP_,27);
DYNX(W_,37) = DYNX(DP_,28);
DYNX(W_,47) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 2], gearbox.lossyGear.lossTable[2, 2], gearbox.lossyGear.lossTable[3, 2], gearbox.lossyGear.lossTable[4, 2]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,19), 
  DYNX(W_,24), DYNX(W_,29), DYNX(W_,34)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,48) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 3], gearbox.lossyGear.lossTable[2, 3], gearbox.lossyGear.lossTable[3, 3], gearbox.lossyGear.lossTable[4, 3]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,20), 
  DYNX(W_,25), DYNX(W_,30), DYNX(W_,35)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(DYNhelp,0) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 4], gearbox.lossyGear.lossTable[2, 4], gearbox.lossyGear.lossTable[3, 4], gearbox.lossyGear.lossTable[4, 4]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,21), 
  DYNX(W_,26), DYNX(W_,31), DYNX(W_,36)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,49) = fabs(DYNX(DYNhelp,0));
DYNX(DYNhelp,1) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 5], gearbox.lossyGear.lossTable[2, 5], gearbox.lossyGear.lossTable[3, 5], gearbox.lossyGear.lossTable[4, 5]}, 0, 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,22), 
  DYNX(W_,27), DYNX(W_,32), DYNX(W_,37)), 0, 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,50) = fabs(DYNX(DYNhelp,1));
DYNX(DYNhelp,2) = fabs(DYNX(W_,47)-1.0);
DYNX(DYNhelp,3) = fabs(DYNX(W_,48)-1.0);
DYNX(W_,51) = IF DYNX(DYNhelp,2) <= 1E-15 AND DYNX(DYNhelp,3) <= 1E-15 THEN 
  DYNX(W_,49)/(double)(2) ELSE divGuarded(DYNX(W_,49)-DYNX(W_,50),
  "gearbox.lossyGear.tau_bf1_0-gearbox.lossyGear.tau_bf2_0",DYNX(W_,47)-
  divinvGuarded(DYNX(W_,48),"gearbox.lossyGear.eta_mf2_0"),"gearbox.lossyGear.eta_mf1_0-1.0/gearbox.lossyGear.eta_mf2_0");
DYNX(W_,52) = DYNX(DP_,29);
DYNX(W_,53) = DYNX(DP_,30);
DYNX(W_,54) = DYNX(DP_,31);
DYNX(W_,59) = DYNX(W_,54)/(double)(2);
DYNX(W_,60) =  -DYNX(W_,59);
BoundParameterConstantSection
DYNX(W_,39) = (PushModelContext(1,"Modelica.Math.Matrices.isEqual(gearbox.lossyGear.lossTable, [0, 1, 1, 0, 0], 1E-15)")
  Modelica_Math_Matrices_isEqual(RealTemporaryDense( &DYNX(W_,18), 2, 4, 5), 
  RealTemporaryDense( DymArrays1, 2, 1, 5), 1E-15));
PopAllMarks();
DYNX(W_,4) = DYNX(DP_,0)*(1+DYNX(DP_,2)*(DYNX(W_,3)-DYNX(DP_,1)));
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,5) = DYNX(DP_,40);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,73);
InitialSection
InitialSection2
DYNX(X_,5) = DYNX(DP_,40);
DYNX(W_,74) = DYNX(DP_,36)+(IF LessTime(DYNX(DP_,37), 0) THEN 0 ELSE 
  DYNX(DP_,35));
DYNX(W_,126) = DYNX(W_,74)-DYNX(X_,4);
DYNX(W_,127) = DYNX(DP_,38)*(DYNX(X_,5)+DYNX(W_,126));
DYNX(W_,75) = homotopy(IF GreaterS(DYNX(W_,127),"limiter.u", DYNX(DP_,44),
  "limiter.uMax", 0) THEN DYNX(DP_,44) ELSE IF LessS(DYNX(W_,127),"limiter.u", 
  DYNX(DP_,45),"limiter.uMin", 1) THEN DYNX(DP_,45) ELSE DYNX(W_,127), 
  DYNX(W_,127));
InitialSection
InitialSection2
DYNX(W_,73) = DYNX(Aux_,0);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(F_,1) = DYNX(X_,4);
DYNX(W_,74) = DYNX(DP_,36)+(IF LessTime(DYNX(DP_,37), 0) THEN 0 ELSE 
  DYNX(DP_,35));
DYNX(W_,126) = DYNX(W_,74)-DYNX(X_,4);
if (NewParameters_) {
DYNX(DYNhelp,4) = divinvGuarded(DYNX(DP_,39),"PI.T");
}
DYNX(F_,5) = DYNX(DYNhelp,4)*DYNX(W_,126);
DYNX(W_,94) = DYNX(X_,4)-DYNX(X_,3);
DYNX(W_,85) = DYNX(W_,17)*DYNX(W_,94);
DYNX(W_,80) = DYNX(DP_,4)*DYNX(W_,85);
DYNX(W_,76) = DYNX(W_,4)*DYNX(X_,0);
DYNX(W_,127) = DYNX(DP_,38)*(DYNX(X_,5)+DYNX(W_,126));
DYNX(W_,75) = IF GreaterS(DYNX(W_,127),"limiter.u", DYNX(DP_,44),"limiter.uMax",
   0) THEN DYNX(DP_,44) ELSE IF LessS(DYNX(W_,127),"limiter.u", DYNX(DP_,45),
  "limiter.uMin", 1) THEN DYNX(DP_,45) ELSE DYNX(W_,127);
DYNX(W_,77) = DYNX(W_,76)+DYNX(W_,75);
DYNX(W_,79) = DYNX(W_,80)-DYNX(W_,77);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 0);
SolveScalarLinearParametric(DYNX(DP_,3),"inductor.L", DYNX(W_,79),"inductor.v", 
  DYNX(F_,0),"der(inductor.i)");
 /* End of Equation Block */ 

DYNX(W_,125) = DYNX(DP_,33)*(IF GreaterEqualS(DYNX(X_,4),"der(quadraticSpeedDependentTorque.phi)",
   0,"0", 2) THEN sqr(divGuarded(DYNX(X_,4),"der(quadraticSpeedDependentTorque.phi)",
  DYNX(DP_,34),"quadraticSpeedDependentTorque.w_nominal")) ELSE  -sqr(divGuarded
  (DYNX(X_,4),"der(quadraticSpeedDependentTorque.phi)",DYNX(DP_,34),
  "quadraticSpeedDependentTorque.w_nominal")));
DYNX(W_,123) = IF initial() THEN (IF Greater(DYNX(X_,2),"gearbox.elastoBacklash.phi_rel",
   1.5*DYNX(W_,59),"1.5*gearbox.elastoBacklash.bMax", 3) THEN DYNX(W_,52)*(
  DYNX(X_,2)-DYNX(W_,59)) ELSE IF Less(DYNX(X_,2),"gearbox.elastoBacklash.phi_rel",
   1.5*DYNX(W_,60),"1.5*gearbox.elastoBacklash.bMin", 4) THEN DYNX(W_,52)*(
  DYNX(X_,2)-DYNX(W_,60)) ELSE 0.3333333333333333*DYNX(W_,52)*DYNX(X_,2)) ELSE 
  IF fabs(DYNX(W_,54)) <= 1E-10 THEN DYNX(W_,52)*DYNX(X_,2) ELSE IF Greater(
  DYNX(X_,2),"gearbox.elastoBacklash.phi_rel", DYNX(W_,59),"gearbox.elastoBacklash.bMax",
   5) THEN DYNX(W_,52)*(DYNX(X_,2)-DYNX(W_,59)) ELSE IF Less(DYNX(X_,2),
  "gearbox.elastoBacklash.phi_rel", DYNX(W_,60),"gearbox.elastoBacklash.bMin", 6)
   THEN DYNX(W_,52)*(DYNX(X_,2)-DYNX(W_,60)) ELSE 0;
DYNX(W_,124) = DYNX(W_,53)*DYNX(X_,3);
DYNX(W_,87) = IF initial() THEN DYNX(W_,123)+DYNX(W_,124) ELSE IF fabs(
  DYNX(W_,54)) <= 1E-10 THEN DYNX(W_,123)+DYNX(W_,124) ELSE IF Greater(
  DYNX(X_,2),"gearbox.elastoBacklash.phi_rel", DYNX(W_,59),"gearbox.elastoBacklash.bMax",
   5) THEN (IF DYNX(W_,123)+DYNX(W_,124) <= 0 THEN 0 ELSE DYNX(W_,123)+RealBmin(
  DYNX(W_,123), DYNX(W_,124))) ELSE IF Less(DYNX(X_,2),"gearbox.elastoBacklash.phi_rel",
   DYNX(W_,60),"gearbox.elastoBacklash.bMin", 6) THEN (IF DYNX(W_,123)+
  DYNX(W_,124) >= 0 THEN 0 ELSE DYNX(W_,123)+RealBmax(DYNX(W_,123), DYNX(W_,124)))
   ELSE 0;
 /* Linear system of equations to solve. */
DYNX(F_,4) = RememberSimple_(DYNX(F_,4), 1);
SolveScalarLinearParametric(DYNX(DP_,32),"Propeller.J", DYNX(W_,125)-DYNX(W_,87),
  "Propeller.flange_b.tau-( -Propeller.flange_a.tau)", DYNX(F_,4),
  "der(Propeller.w)");
 /* End of Equation Block */ 

DYNX(F_,2) = DYNX(X_,3);
DYNX(W_,97) = IF DYNX(W_,39) THEN 1 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 2], gearbox.lossyGear.lossTable[2, 2], gearbox.lossyGear.lossTable[3, 2], gearbox.lossyGear.lossTable[4, 2]}, noEvent(abs(gearbox.lossyGear.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,19), 
  DYNX(W_,24), DYNX(W_,29), DYNX(W_,34)), fabs(DYNX(W_,85)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,101) = IF DYNX(W_,39) THEN 1 ELSE DYNX(W_,97);
DYNX(W_,98) = IF DYNX(W_,39) THEN 1 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 3], gearbox.lossyGear.lossTable[2, 3], gearbox.lossyGear.lossTable[3, 3], gearbox.lossyGear.lossTable[4, 3]}, noEvent(abs(gearbox.lossyGear.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,20), 
  DYNX(W_,25), DYNX(W_,30), DYNX(W_,35)), fabs(DYNX(W_,85)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,102) = IF DYNX(W_,39) THEN 1 ELSE DYNX(W_,98);
DYNX(W_,99) = IF DYNX(W_,39) THEN 0 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 4], gearbox.lossyGear.lossTable[2, 4], gearbox.lossyGear.lossTable[3, 4], gearbox.lossyGear.lossTable[4, 4]}, noEvent(abs(gearbox.lossyGear.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,21), 
  DYNX(W_,26), DYNX(W_,31), DYNX(W_,36)), fabs(DYNX(W_,85)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,105) = IF DYNX(W_,39) THEN 0 ELSE fabs(DYNX(W_,99));
DYNX(W_,100) = IF DYNX(W_,39) THEN 0 ELSE (PushModelContext(1,"Modelica.Math.Vectors.interpolate({gearbox.lossyGear.lossTable[1, 1], gearbox.lossyGear.lossTable[2, 1], gearbox.lossyGear.lossTable[3, 1], gearbox.lossyGear.lossTable[4, 1]}, {gearbox.lossyGear.lossTable[1, 5], gearbox.lossyGear.lossTable[2, 5], gearbox.lossyGear.lossTable[3, 5], gearbox.lossyGear.lossTable[4, 5]}, noEvent(abs(gearbox.lossyGear.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealScalarArray ( 4, DYNX(W_,18), 
  DYNX(W_,23), DYNX(W_,28), DYNX(W_,33)), RealScalarArray ( 4, DYNX(W_,22), 
  DYNX(W_,27), DYNX(W_,32), DYNX(W_,37)), fabs(DYNX(W_,85)), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,106) = IF DYNX(W_,39) THEN 0 ELSE fabs(DYNX(W_,100));
DYNX(DYNhelp,5) = fabs(DYNX(W_,101)-1.0);
DYNX(DYNhelp,6) = fabs(DYNX(W_,102)-1.0);
DYNX(W_,103) = IF DYNX(DYNhelp,5) <= 1E-15 AND DYNX(DYNhelp,6) <= 1E-15 THEN 
  DYNX(W_,105)/(double)(2) ELSE divGuarded(DYNX(W_,105)-DYNX(W_,106),
  "gearbox.lossyGear.tau_bf1-gearbox.lossyGear.tau_bf2",DYNX(W_,101)-
  divinvGuarded(DYNX(W_,102),"gearbox.lossyGear.eta_mf2"),"gearbox.lossyGear.eta_mf1-1.0/gearbox.lossyGear.eta_mf2");
DYNX(W_,82) = DYNX(DP_,4)*DYNX(X_,0);

MixedSystemOfEquations(19, DYNX(DYNhelp,7))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 16 common subexpressions used in 18 expressions */
  /* Of the common subexpressions 16 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,26) = IF DYNX(W_,69) THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,27) = IF DYNX(W_,39) THEN 0.0 ELSE IF DYNX(W_,72) THEN 0.0 ELSE 
    IF DYNX(W_,70) OR PRE(DYNX(W_,73), 0) == 1 THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,28) = DYNX(DYNhelp,26)*DYNX(DYNhelp,27);
  DYNX(DYNhelp,29) = IF DYNX(W_,39) THEN 0.0 ELSE IF DYNX(W_,72) THEN 0.0 ELSE 
    IF DYNX(W_,70) OR PRE(DYNX(W_,73), 0) == 1 THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,30) = DYNX(DYNhelp,26)*DYNX(DYNhelp,29);
  DYNX(DYNhelp,31) = divinvGuarded(DYNX(W_,102),"gearbox.lossyGear.eta_mf2");
  DYNX(DYNhelp,32) = IF DYNX(W_,69) THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,33) = DYNX(DYNhelp,32)*DYNX(DYNhelp,29);
  DYNX(DYNhelp,34) = DYNX(DYNhelp,32)*DYNX(DYNhelp,27);
  DYNX(DYNhelp,35) = (DYNX(DYNhelp,31)-1)*DYNX(DYNhelp,30)+(DYNX(W_,101)-1)*
    DYNX(DYNhelp,33)+(DYNX(DYNhelp,31)-1.0)*DYNX(DYNhelp,34)+(DYNX(W_,101)-1.0)*
    DYNX(DYNhelp,28);
  /* Automatic tearing of linear system of 10 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  DYNX(DYNhelp,36) = DYNX(DP_,6)*DYNX(DYNhelp,35);
  DYNX(DYNhelp,37) = IF DYNX(W_,72) THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,38) = IF DYNX(W_,72) THEN 0.0 ELSE -1.0;
  DYNX(DYNhelp,39) = DYNX(DP_,6)*DYNX(W_,17);
  {
  const char*const varnames_[]={"gearbox.lossyGear.sa", "gearbox.lossyGear.tauLoss"};
  const double nominal_[]={1.0, 1.0};
  DYNX(W_,96)=RememberSimple_(DYNX(W_,96), 2);
  DYNX(W_,115)=RememberSimple_(DYNX(W_,115), 3);
  SolveLinear2by2( -((IF DYNX(W_,39) THEN 0.0 ELSE IF DYNX(W_,72) THEN 1.0 ELSE 
    0.0)+DYNX(DYNhelp,36)*DYNX(DYNhelp,37)), 1.0-DYNX(DYNhelp,36)*
    DYNX(DYNhelp,38), 
  DYNX(DYNhelp,39)*DYNX(DYNhelp,37), DYNX(W_,17)+DYNX(DYNhelp,39)*
    DYNX(DYNhelp,38), 
  DYNX(DYNhelp,28)*DYNX(W_,105)-(DYNX(DYNhelp,30)*DYNX(W_,106)-DYNX(DYNhelp,35)*
    DYNX(W_,82)+DYNX(DYNhelp,33)*DYNX(W_,105))+DYNX(DYNhelp,34)*DYNX(W_,106), 
    DYNX(W_,87)-DYNX(W_,17)*DYNX(W_,82), &DYNX(W_,96), &DYNX(W_,115), 
  varnames_, &MixedFailFlag_, "simulation.linear[1]");
  }
  DYNX(W_,86) = IF DYNX(W_,72) THEN 0 ELSE DYNX(W_,96)-DYNX(W_,115);
  DYNX(W_,83) = DYNX(DP_,6)*DYNX(W_,86)+DYNX(W_,82);
  DYNX(DYNhelp,40) = (1-DYNX(DYNhelp,31))*DYNX(W_,83);
  DYNX(W_,110) =  -(DYNX(DYNhelp,40)+DYNX(W_,106));
  DYNX(DYNhelp,41) = (1-DYNX(W_,101))*DYNX(W_,83);
  DYNX(W_,109) =  -(DYNX(DYNhelp,41)+DYNX(W_,105));
  DYNX(W_,117) = IF DYNX(W_,69) THEN DYNX(W_,110) ELSE DYNX(W_,109);
  DYNX(W_,108) = DYNX(W_,106)-DYNX(DYNhelp,40);
  DYNX(W_,107) = DYNX(W_,105)-DYNX(DYNhelp,41);
  DYNX(W_,116) = IF DYNX(W_,69) THEN DYNX(W_,107) ELSE DYNX(W_,108);
   /* End of Equation Block */ 

  DYNX(W_,104) = IF DYNX(W_,39) THEN  -DYNX(W_,83) ELSE IF DYNX(W_,72) THEN  -
    DYNX(W_,83) ELSE IF DYNX(W_,70) OR PRE(DYNX(W_,73), 0) == 1 THEN  -(
    DYNX(W_,83)+DYNX(W_,103)) ELSE DYNX(W_,103)-DYNX(W_,83);
  DYNX(W_,113) =  -((1-DYNX(W_,47))*DYNX(W_,83)+DYNX(W_,49));
  if (NewParameters_) {
  DYNX(DYNhelp,42) = divinvGuarded(DYNX(W_,48),"gearbox.lossyGear.eta_mf2_0");
  }
  DYNX(W_,114) =  -((1-DYNX(DYNhelp,42))*DYNX(W_,83)+DYNX(W_,50));
  DYNX(W_,121) = DYNX(W_,51)-DYNX(W_,83);
  DYNX(W_,119) = IF DYNX(W_,121) > 0 THEN DYNX(W_,114) ELSE DYNX(W_,113);
  DYNX(W_,112) = DYNX(W_,50)-(1-DYNX(DYNhelp,42))*DYNX(W_,83);
  DYNX(W_,111) = DYNX(W_,49)-(1-DYNX(W_,47))*DYNX(W_,83);
  DYNX(W_,120) =  -(DYNX(W_,83)+DYNX(W_,51));
  DYNX(W_,118) = IF DYNX(W_,120) > 0 THEN DYNX(W_,111) ELSE DYNX(W_,112);

  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,69),"gearbox.lossyGear.tau_etaPos", GreaterEqual(
    DYNX(W_,104),"gearbox.lossyGear.tau_eta", 0,"0", 7));
  UpdateVariableNamed(DYNX(W_,71),"gearbox.lossyGear.startBackward", PRE(
    DYNX(W_,73), 0) == 0 AND Less(DYNX(W_,96),"gearbox.lossyGear.sa", 
    DYNX(W_,119),"gearbox.lossyGear.tauLossMin_m", 8) OR initial() AND Less(
    DYNX(W_,85),"gearbox.lossyGear.w_a", 0,"0", 9));
  UpdateVariableNamed(DYNX(W_,70),"gearbox.lossyGear.startForward", PRE(
    DYNX(W_,73), 0) == 0 AND Greater(DYNX(W_,96),"gearbox.lossyGear.sa", 
    DYNX(W_,118),"gearbox.lossyGear.tauLossMax_p", 10) OR initial() AND Greater(
    DYNX(W_,85),"gearbox.lossyGear.w_a", 0,"0", 11));
  UpdateVariableNamed(DYNX(W_,72),"gearbox.lossyGear.locked",  NOT (DYNX(W_,39)
     OR PRE(DYNX(W_,73), 0) == 1 OR DYNX(W_,70) OR PRE(DYNX(W_,73), 0) == -1 OR 
    DYNX(W_,71)));
  MixedModeInit(5, DYNX(DYNhelp,43))
  ThetaMixedCross(0,7)
  ThetaMixedCross(1,8)
  ThetaMixedCross(2,9)
  ThetaMixedCross(3,10)
  ThetaMixedCross(4,11)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,109), 1)
  UpdateReal(DYNX(W_,110), 2)
  UpdateReal(DYNX(W_,117), 3)
  UpdateReal(DYNX(W_,108), 4)
  UpdateReal(DYNX(W_,107), 5)
  UpdateReal(DYNX(W_,104), 6)
  UpdateReal(DYNX(W_,116), 7)
  UpdateReal(DYNX(W_,113), 8)
  UpdateReal(DYNX(W_,114), 9)
  UpdateReal(DYNX(W_,121), 10)
  UpdateReal(DYNX(W_,119), 11)
  UpdateReal(DYNX(W_,112), 12)
  UpdateReal(DYNX(W_,111), 13)
  UpdateReal(DYNX(W_,120), 14)
  UpdateReal(DYNX(W_,118), 15)
  UpdateReal(DYNX(W_,96), 16)
  UpdateReal(DYNX(W_,115), 17)
  UpdateReal(DYNX(W_,83), 18)
  UpdateReal(DYNX(W_,86), 19)
EndMixedSystemOfEquations

 /* Linear system of equations to solve. */
DYNX(W_,95) = RememberSimple_(DYNX(W_,95), 4);
SolveScalarLinearParametric( -DYNX(W_,17)," -gearbox.lossyGear.ratio",  -
  DYNX(W_,86)," -der(gearbox.lossyGear.w_a)", DYNX(W_,95),"der(gearbox.lossyGear.phi_b, 2)");
 /* End of Equation Block */ 

DYNX(F_,3) = DYNX(F_,4)-DYNX(W_,95);
DYNX(W_,122) = IF initial() THEN DYNX(W_,124)*DYNX(X_,3) ELSE IF fabs(
  DYNX(W_,54)) <= 1E-10 THEN DYNX(W_,124)*DYNX(X_,3) ELSE IF Greater(DYNX(X_,2),
  "gearbox.elastoBacklash.phi_rel", DYNX(W_,59),"gearbox.elastoBacklash.bMax", 5)
   THEN (IF DYNX(W_,123)+DYNX(W_,124) <= 0 THEN 0 ELSE RealBmin(DYNX(W_,123), 
  DYNX(W_,124))*DYNX(X_,3)) ELSE IF Less(DYNX(X_,2),"gearbox.elastoBacklash.phi_rel",
   DYNX(W_,60),"gearbox.elastoBacklash.bMin", 6) THEN (IF DYNX(W_,123)+
  DYNX(W_,124) >= 0 THEN 0 ELSE RealBmax(DYNX(W_,123), DYNX(W_,124))*DYNX(X_,3))
   ELSE 0;
DYNX(W_,91) = DYNX(W_,115)*DYNX(W_,85);
DYNX(W_,128) = DYNX(W_,122)+DYNX(W_,91);
 /* Linear system of equations to solve. */
DYNX(F_,6) = RememberSimple_(DYNX(F_,6), 5);
SolveScalarLinearParametric(DYNX(DP_,43),"heatCapacitor.C", DYNX(W_,128),
  "heatCapacitor.port.Q_flow", DYNX(F_,6),"der(heatCapacitor.T)");
 /* End of Equation Block */ 


AcceptedSection1
DYNX(W_,73) = IF DYNX(W_,39) THEN 2 ELSE IF (PRE(DYNX(W_,73), 0) == 1 OR 
  DYNX(W_,70)) AND Greater(DYNX(W_,85),"gearbox.lossyGear.w_a", 0,"0", 11) THEN 1
   ELSE IF (PRE(DYNX(W_,73), 0) == -1 OR DYNX(W_,71)) AND Less(DYNX(W_,85),
  "gearbox.lossyGear.w_a", 0,"0", 9) THEN -1 ELSE 0;

AcceptedSection2
DYNX(W_,93) =  -(DYNX(X_,2)-DYNX(X_,1)+DYNX(DP_,7));
DYNX(W_,92) = DYNX(W_,17)*DYNX(W_,93);
DYNX(W_,84) = DYNX(W_,92)+DYNX(DP_,7);
DYNX(W_,81) = DYNX(W_,84)-DYNX(DP_,5);
DYNX(W_,90) = DYNX(W_,93)+DYNX(DP_,7);
DYNX(W_,78) = DYNX(W_,76)*DYNX(X_,0);
DYNX(W_,88) = DYNX(W_,87)-DYNX(W_,83);
 /* Linear system of equations to solve. */
DYNX(W_,129) = RememberSimple_(DYNX(W_,129), 6);
SolveScalarLinearParametric( -DYNX(DP_,42)," -thermalConductor.G",  -
  DYNX(W_,128)," -thermalConductor.Q_flow", DYNX(W_,129),"thermalConductor.dT");
 /* End of Equation Block */ 

DYNX(W_,89) = DYNX(W_,129)+DYNX(X_,6);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("signalVoltage.p.v", "Potential at the pin [V]", 75, 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("signalVoltage.p.i", "Current flowing into the pin [A]", \
"inductor.i", 1, 1, 0, 132)
DeclareVariable("signalVoltage.n.v", "Potential at the pin [V]", 0, 0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("signalVoltage.n.i", "Current flowing into the pin [A]", \
"inductor.i", -1, 1, 0, 132)
DeclareAlias2("signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "signalVoltage.p.v", 1, 5, 75, 0)
DeclareAlias2("signalVoltage.i", "Current flowing from pin p to pin n [A]", \
"inductor.i", 1, 1, 0, 0)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 1, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("ground.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareParameter("resistor.R", "Resistance at temperature T_ref [Ohm]", 0, 0.1, \
0.0,0.0,0.0,0,560)
DeclareParameter("resistor.T_ref", "Reference temperature [K|degC]", 1, 300.15, \
0.0,1E+100,300.0,0,560)
DeclareParameter("resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 76,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("resistor.p.v", "Potential at the pin [V]", 77, 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("resistor.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareAlias2("resistor.n.v", "Potential at the pin [V]", "signalVoltage.p.v", 1,\
 5, 75, 4)
DeclareAlias2("resistor.n.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 1, 0, 132)
DeclareAlias2("resistor.i", "Current flowing from pin p to pin n [A]", \
"inductor.i", 1, 1, 0, 0)
DeclareVariable("resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 2, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 3, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 78, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"resistor.T", 1, 5, 3, 0)
DeclareVariable("resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 4, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 79,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inductor.p.v", "Potential at the pin [V]", 80, 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("inductor.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareAlias2("inductor.n.v", "Potential at the pin [V]", "resistor.p.v", 1, 5, 77,\
 4)
DeclareAlias2("inductor.n.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 1, 0, 132)
DeclareState("inductor.i", "Current flowing from pin p to pin n [A]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("inductor.L", "Inductance [H]", 3, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 5, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("emf.k", "Transformation coefficient [N.m/A]", 4, 0.3, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("emf.v", "Voltage drop between the two pins [V]", "inductor.p.v", 1,\
 5, 80, 0)
DeclareAlias2("emf.i", "Current flowing from positive to negative pin [A]", \
"inductor.i", -1, 1, 0, 0)
DeclareVariable("emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 81, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia.w", 1, 5, 85, 0)
DeclareAlias2("emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "inertia.w", 1, 5, 85, 0)
DeclareVariable("emf.tau", "Torque of flange [N.m]", 82, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("emf.tauElectrical", "Electrical torque [N.m]", "emf.tau", -1, 5, 82,\
 0)
DeclareAlias2("emf.p.v", "Potential at the pin [V]", "inductor.p.v", 1, 5, 80, 4)
DeclareAlias2("emf.p.i", "Current flowing into the pin [A]", "inductor.i", -1, 1,\
 0, 132)
DeclareVariable("emf.n.v", "Potential at the pin [V]", 6, 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("emf.n.i", "Current flowing into the pin [A]", "inductor.i", 1, 1,\
 0, 132)
DeclareAlias2("emf.flange.phi", "Absolute rotation angle of flange [rad|deg]", \
"inertia.phi", 1, 5, 84, 4)
DeclareAlias2("emf.flange.tau", "Cut torque in the flange [N.m]", "emf.tau", 1, 5,\
 82, 132)
DeclareParameter("emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]", 5,\
 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("emf.fixed.flange.tau", "Cut torque in the flange [N.m]", \
"emf.tau", 1, 5, 82, 1156)
DeclareAlias2("emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "emf.tau", -1, 5, 82, 1024)
DeclareAlias2("emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "emf.fixed.phi0", 1, 7, 5, 1024)
DeclareAlias2("emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "emf.tau", -1, 5, 82, 1156)
DeclareAlias2("inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 5, 84, 4)
DeclareAlias2("inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"emf.tau", -1, 5, 82, 132)
DeclareAlias2("inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 5, 84, 4)
DeclareVariable("inertia.flange_b.tau", "Cut torque in the flange [N.m]", 83, \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("inertia.J", "Moment of inertia [kg.m2]", 6, 0.001, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 7, 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 84, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "inertia.w", 1, 5, 85, 0)
DeclareVariable("inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 85, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 86, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 5, 86, 0)
DeclareVariable("ground1.p.v", "Potential at the pin [V]", 8, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("ground1.p.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 1, 0, 132)
DeclareState("speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 1, 0, 0.0,0.0,0.0,0,568)
DeclareDerivative("speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("speedSensor.flange.tau", "Cut torque in the flange [N.m]", 9, 0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "speedSensor.flange.der(phi)", 1, 6, 1, 0)
DeclareVariable("gearbox.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 10, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 5, 84, 4)
DeclareAlias2("gearbox.flange_a.tau", "Cut torque in the flange [N.m]", \
"inertia.flange_b.tau", -1, 5, 83, 132)
DeclareAlias2("gearbox.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 4)
DeclareVariable("gearbox.flange_b.tau", "Cut torque in the flange [N.m]", 87, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("gearbox.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 7, 1028)
DeclareVariable("gearbox.internalSupport.tau", "Cut torque in the flange [N.m]",\
 11, 0.0, 0.0,0.0,0.0,0,2825)
DeclareParameter("gearbox.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 7, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("gearbox.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 7, 1028)
DeclareVariable("gearbox.fixed.flange.tau", "Cut torque in the flange [N.m]", 88,\
 0.0, 0.0,0.0,0.0,0,2824)
DeclareParameter("gearbox.ratio", "Transmission ratio (flange_a.phi/flange_b.phi)",\
 8, 2, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 1]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 9, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 2]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 10, 0.99, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 3]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 11, 0.99, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 4]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 12, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[1, 5]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 13, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[2, 1]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 14, 50.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[2, 2]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 15, 0.98, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[2, 3]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 16, 0.98, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[2, 4]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 17, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[2, 5]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 18, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[3, 1]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 19, 100.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[3, 2]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 20, 0.97, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[3, 3]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 21, 0.97, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[3, 4]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 22, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[3, 5]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 23, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[4, 1]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 24, 210.0, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[4, 2]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 25, 0.96, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[4, 3]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 26, 0.96, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[4, 4]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 27, 1.5, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.lossTable[4, 5]", "Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)",\
 28, 1.5, 0.0,0.0,0.0,0,560)
DeclareParameter("gearbox.c", "Gear elasticity (spring constant) [N.m/rad]", 29,\
 100000.0, 1E-60,1E+100,0.0,0,560)
DeclareParameter("gearbox.d", "Gear damping (relative damping) [N.m.s/rad]", 30,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("gearbox.b", "Total backlash [rad|deg]", 31, 0, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("gearbox.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 12, 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("gearbox.useHeatPort", "= true, if HeatPort is enabled [:#(type=Boolean)]",\
 13, true, 0.0,0.0,0.0,0,1539)
DeclareVariable("gearbox.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 14, 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("gearbox.heatPort.T", "Port temperature [K|degC]", \
"gearbox.internalHeatPort.T", 1, 5, 89, 4)
DeclareAlias2("gearbox.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", -1, 5, 128, 132)
DeclareVariable("gearbox.internalHeatPort.T", "Port temperature [K|degC]", 89, \
288.15, 0.0,1E+100,300.0,0,2568)
DeclareVariable("gearbox.internalHeatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 15, 0.0, 0.0,0.0,0.0,0,2825)
DeclareState("gearbox.phi_rel", "Relative rotation angle over gear elasticity (= flange_b.phi - lossyGear.flange_b.phi) [rad|deg]",\
 2, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("gearbox.der(phi_rel)", "der(Relative rotation angle over gear elasticity (= flange_b.phi - lossyGear.flange_b.phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("gearbox.w_rel", "Relative angular velocity over gear elasticity (= der(phi_rel)) [rad/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("gearbox.der(w_rel)", "der(Relative angular velocity over gear elasticity (= der(phi_rel))) [rad/s2]",\
 3, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gearbox.a_rel", "Relative angular acceleration over gear elasticity (= der(w_rel)) [rad/s2]",\
 "gearbox.der(w_rel)", 1, 6, 3, 0)
DeclareVariable("gearbox.lossyGear.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 16, true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.lossyGear.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 5, 84, 4)
DeclareAlias2("gearbox.lossyGear.flange_a.tau", "Cut torque in the flange [N.m]",\
 "inertia.flange_b.tau", -1, 5, 83, 132)
DeclareVariable("gearbox.lossyGear.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 90, 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("gearbox.lossyGear.flange_b.tau", "Cut torque in the flange [N.m]",\
 "gearbox.flange_b.tau", 1, 5, 87, 132)
DeclareAlias2("gearbox.lossyGear.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 7, 4)
DeclareAlias2("gearbox.lossyGear.support.tau", "Cut torque in the flange [N.m]",\
 "gearbox.fixed.flange.tau", -1, 5, 88, 132)
DeclareAlias2("gearbox.lossyGear.phi_support", "Absolute angle of support flange [rad|deg]",\
 "gearbox.fixed.phi0", 1, 7, 7, 1024)
DeclareVariable("gearbox.lossyGear.ratio", "Transmission ratio (flange_a.phi/flange_b.phi)",\
 17, 1, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 18, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 19, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 20, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 21, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[1, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 22, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[2, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 23, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[2, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 24, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[2, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 25, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[2, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 26, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[2, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 27, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[3, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 28, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[3, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 29, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[3, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 30, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[3, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 31, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[3, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 32, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[4, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 33, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[4, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 34, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[4, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 35, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[4, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 36, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.lossTable[4, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 37, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("gearbox.lossyGear.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 38, true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.lossyGear.heatPort.T", "Port temperature [K|degC]", \
"gearbox.internalHeatPort.T", 1, 5, 89, 4)
DeclareAlias2("gearbox.lossyGear.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "gearbox.lossyGear.lossPower", -1, 5, 91, 132)
DeclareVariable("gearbox.lossyGear.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 91, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 92, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gearbox.lossyGear.der(phi_a)", "der(Angle between left shaft flange and support) [rad/s]",\
 "inertia.w", 1, 5, 85, 0)
DeclareVariable("gearbox.lossyGear.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 93, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.der(phi_b)", "der(Angle between right shaft flange and support) [rad/s]",\
 94, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.der(phi_b, 2)", "der(Angle between right shaft flange and support2) [rad/s2]",\
 95, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.sa", "Path parameter for acceleration and torque loss [1]",\
 96, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gearbox.lossyGear.w_a", "Angular velocity of flange_a with respect to support [rad/s]",\
 "inertia.w", 1, 5, 85, 0)
DeclareAlias2("gearbox.lossyGear.der(w_a)", "der(Angular velocity of flange_a with respect to support) [rad/s2]",\
 "inertia.der(w)", 1, 5, 86, 0)
DeclareAlias2("gearbox.lossyGear.a_a", "Angular acceleration of flange_a with respect to support [rad/s2]",\
 "inertia.der(w)", 1, 5, 86, 0)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 1]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 97, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 2]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 98, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 3]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 99, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.interpolation_result[1, 4]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 100, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.eta_mf1", "Mesh efficiency in case that flange_a is driving [1]",\
 101, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.eta_mf2", "Mesh efficiency in case that flange_b is driving [1]",\
 102, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_bf_a", "Bearing friction torque on flange_a side [N.m]",\
 103, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_eta", "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau) [N.m]",\
 104, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_bf1", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving (= |tau_bf_a*eta_mf1 + tau_bf_b/i|) [N.m]",\
 105, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_bf2", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving (= |tau_bf_a/eta_mf2 + tau_bf_b/i|) [N.m]",\
 106, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant1", "Torque loss if w_a > 0 and flange_a.tau >= 0 [N.m]",\
 107, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant2", "Torque loss if w_a > 0 and flange_a.tau < 0 [N.m]",\
 108, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant3", "Torque loss if w_a < 0 and flange_a.tau >= 0 [N.m]",\
 109, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant4", "Torque loss if w_a < 0 and flange_a.tau < 0 [N.m]",\
 110, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant1_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau >= 0) [N.m]",\
 111, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant2_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau < 0) [N.m]",\
 112, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant3_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau >=0) [N.m]",\
 113, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.quadrant4_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau < 0) [N.m]",\
 114, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLoss", "Torque loss due to friction in the gear teeth and in the bearings [N.m]",\
 115, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMax", "Torque loss for positive speed [N.m]",\
 116, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMin", "Torque loss for negative speed [N.m]",\
 117, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMax_p", "Torque loss for positive speed [N.m]",\
 118, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tauLossMin_m", "Torque loss for negative speed [N.m]",\
 119, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_aPos", "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative) [:#(type=Boolean)]",\
 69, true, 0.0,0.0,0.0,0,706)
DeclareAlias2("gearbox.lossyGear.tau_etaPos", "= true, if torque tau_eta is not negative [:#(type=Boolean)]",\
 "gearbox.lossyGear.tau_aPos", 1, 5, 69, 65)
DeclareVariable("gearbox.lossyGear.startForward", "= true, if starting to roll forward [:#(type=Boolean)]",\
 70, false, 0.0,0.0,0.0,0,706)
DeclareVariable("gearbox.lossyGear.startBackward", "= true, if starting to roll backward [:#(type=Boolean)]",\
 71, false, 0.0,0.0,0.0,0,706)
DeclareVariable("gearbox.lossyGear.locked", "= true, if gear is locked [:#(type=Boolean)]",\
 72, false, 0.0,0.0,0.0,0,706)
DeclareVariable("gearbox.lossyGear.ideal", "= true, if losses are neglected (that is lossTable = [0, 1, 1, 0, 0]) [:#(type=Boolean)]",\
 39, false, 0.0,0.0,0.0,0,515)
DeclareVariable("gearbox.lossyGear.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 40, 3, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Free", "Element is not active [:#(type=Integer)]",\
 41, 2, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Forward", "w_a > 0 (forward rolling) [:#(type=Integer)]",\
 42, 1, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Stuck", "w_a = 0 (forward rolling, locked or backward rolling) [:#(type=Integer)]",\
 43, 0, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.Backward", "w_a < 0 (backward rolling) [:#(type=Integer)]",\
 44, -1, 0.0,0.0,0.0,0,517)
DeclareVariable("gearbox.lossyGear.mode", "Mode of friction element (unknown, not active, forward/backward rolling, stuck) [:#(type=Integer)]",\
 73, 2, -1.0,3.0,0.0,0,660)
DeclareVariable("gearbox.lossyGear.tau_eta_p", "tau_eta assuming positive omega [N.m]",\
 120, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.tau_eta_m", "tau_eta assuming negative omega [N.m]",\
 121, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.lossyGear.unitAngularAcceleration", "[rad/s2]", 45, 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.unitTorque", "[N.m]", 46, 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.eta_mf1_0", "[1]", 47, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.eta_mf2_0", "[1]", 48, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.tau_bf1_0", "[N.m]", 49, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.tau_bf2_0", "[N.m]", 50, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.lossyGear.tau_bf_a_0", "[N.m]", 51, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.elastoBacklash.c", "Spring constant (c > 0 required) [N.m/rad]",\
 52, 100000.0, 1E-60,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.d", "Damping constant [N.m.s/rad]", 53, 0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.b", "Total backlash [rad|deg]", 54, 0.0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.phi_rel0", "Unstretched spring angle [rad|deg]",\
 55, 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("gearbox.elastoBacklash.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 "gearbox.phi_rel", 1, 1, 2, 0)
DeclareAlias2("gearbox.elastoBacklash.der(phi_rel)", "der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]",\
 "gearbox.w_rel", 1, 1, 3, 0)
DeclareAlias2("gearbox.elastoBacklash.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 "gearbox.w_rel", 1, 1, 3, 0)
DeclareAlias2("gearbox.elastoBacklash.der(w_rel)", "der(Relative angular velocity (= der(phi_rel))) [rad/s2]",\
 "gearbox.der(w_rel)", 1, 6, 3, 0)
DeclareAlias2("gearbox.elastoBacklash.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "gearbox.der(w_rel)", 1, 6, 3, 0)
DeclareAlias2("gearbox.elastoBacklash.tau", "Torque between flanges (= flange_b.tau) [N.m]",\
 "gearbox.flange_b.tau", 1, 5, 87, 0)
DeclareAlias2("gearbox.elastoBacklash.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "gearbox.lossyGear.flange_b.phi", 1, 5, 90, 4)
DeclareAlias2("gearbox.elastoBacklash.flange_a.tau", "Cut torque in the flange [N.m]",\
 "gearbox.flange_b.tau", -1, 5, 87, 132)
DeclareAlias2("gearbox.elastoBacklash.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 4)
DeclareAlias2("gearbox.elastoBacklash.flange_b.tau", "Cut torque in the flange [N.m]",\
 "gearbox.flange_b.tau", 1, 5, 87, 132)
DeclareVariable("gearbox.elastoBacklash.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 56, 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("gearbox.elastoBacklash.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 57, 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("gearbox.elastoBacklash.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 58, true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gearbox.elastoBacklash.heatPort.T", "Port temperature [K|degC]", \
"gearbox.internalHeatPort.T", 1, 5, 89, 4)
DeclareAlias2("gearbox.elastoBacklash.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "gearbox.elastoBacklash.lossPower", -1, 5, 122, 132)
DeclareVariable("gearbox.elastoBacklash.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 122, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("gearbox.elastoBacklash.bMax", "Backlash in range bMin <= phi_rel - phi_rel0 <= bMax [rad|deg]",\
 59, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.elastoBacklash.bMin", "Backlash in range bMin <= phi_rel - phi_rel0 <= bMax [rad|deg]",\
 60, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("gearbox.elastoBacklash.tau_c", "[N.m]", 123, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("gearbox.elastoBacklash.tau_d", "[N.m]", 124, 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("gearbox.elastoBacklash.phi_diff", "[rad|deg]", "gearbox.phi_rel", 1,\
 1, 2, 1024)
DeclareVariable("gearbox.elastoBacklash.bEps", "Minimum backlash [rad|deg]", 61,\
 1E-10, 0.0,0.0,0.0,0,2561)
DeclareAlias2("Propeller.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 4)
DeclareAlias2("Propeller.flange_a.tau", "Cut torque in the flange [N.m]", \
"gearbox.flange_b.tau", -1, 5, 87, 132)
DeclareAlias2("Propeller.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 4)
DeclareVariable("Propeller.flange_b.tau", "Cut torque in the flange [N.m]", 125,\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("Propeller.J", "Moment of inertia [kg.m2]", 32, 1.09, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("Propeller.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 62, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("Propeller.phi", "Absolute rotation angle of component [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 0)
DeclareAlias2("Propeller.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "Propeller.w", 1, 1, 4, 0)
DeclareState("Propeller.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 4, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("Propeller.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 4, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Propeller.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "Propeller.der(w)", 1, 6, 4, 0)
DeclareVariable("quadraticSpeedDependentTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 63, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("quadraticSpeedDependentTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 4)
DeclareAlias2("quadraticSpeedDependentTorque.flange.tau", "Cut torque in the flange [N.m]",\
 "Propeller.flange_b.tau", -1, 5, 125, 132)
DeclareVariable("quadraticSpeedDependentTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 64, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("quadraticSpeedDependentTorque.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "speedSensor.flange.phi", 1, 1, 1, 0)
DeclareAlias2("quadraticSpeedDependentTorque.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "Propeller.w", 1, 1, 4, 0)
DeclareParameter("quadraticSpeedDependentTorque.tau_nominal", "Nominal torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 33, -100, 0.0,0.0,0.0,0,560)
DeclareVariable("quadraticSpeedDependentTorque.TorqueDirection", \
"Same direction of torque in both directions of rotation [:#(type=Boolean)]", 65,\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("quadraticSpeedDependentTorque.w_nominal", "Nominal speed [rad/s]",\
 34, 210, 1E-15,1E+100,0.0,0,560)
DeclareAlias2("quadraticSpeedDependentTorque.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "Propeller.w", 1, 1, 4, 0)
DeclareAlias2("quadraticSpeedDependentTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "Propeller.flange_b.tau", 1, 5, 125, 0)
DeclareParameter("step.height", "Height of step", 35, 210, 0.0,0.0,0.0,0,560)
DeclareVariable("step.y", "Connector of Real output signal", 74, 0.0, 0.0,0.0,\
0.0,0,640)
DeclareParameter("step.offset", "Offset of output signal y", 36, 0, 0.0,0.0,0.0,\
0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 37, 5, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.k", "Gain [1]", 38, 0.14, 0.0,0.0,0.0,0,560)
DeclareParameter("PI.T", "Time Constant (T>0 required) [s]", 39, 0.1, 1E-60,\
1E+100,0.0,0,560)
DeclareVariable("PI.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 66, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("PI.x_start", "Initial or guess value of state", 40, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("PI.y_start", "Initial value of output", 41, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("PI.u", "Connector of Real input signal", 126, 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("PI.y", "Connector of Real output signal", 127, 0.0, 0.0,0.0,0.0,\
0,512)
DeclareState("PI.x", "State of block", 5, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("PI.der(x)", "der(State of block)", 5, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("feedback.u1", "Commanded input", "step.y", 1, 5, 74, 0)
DeclareAlias2("feedback.u2", "Feedback input", "speedSensor.flange.der(phi)", 1,\
 6, 1, 0)
DeclareAlias2("feedback.y", "", "PI.u", 1, 5, 126, 0)
DeclareVariable("thermalConductor.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 128, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("thermalConductor.dT", "port_a.T - port_b.T [K,]", 129, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("thermalConductor.port_a.T", "Port temperature [K|degC]", \
"gearbox.internalHeatPort.T", 1, 5, 89, 4)
DeclareAlias2("thermalConductor.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", 1, 5, 128, 132)
DeclareAlias2("thermalConductor.port_b.T", "Port temperature [K|degC]", \
"heatCapacitor.T", 1, 1, 6, 4)
DeclareAlias2("thermalConductor.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", -1, 5, 128, 132)
DeclareParameter("thermalConductor.G", "Constant thermal conductance of material [W/K]",\
 42, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("heatCapacitor.C", "Heat capacity of element (= cp*m) [J/K]", 43,\
 3000, 0.0,0.0,0.0,0,560)
DeclareState("heatCapacitor.T", "Temperature of element [K|degC]", 6, 293.15, \
0.0,1E+100,300.0,0,560)
DeclareDerivative("heatCapacitor.der(T)", "der(Temperature of element) [K/s]", 6,\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("heatCapacitor.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "heatCapacitor.der(T)", 1, 6, 6, 0)
DeclareAlias2("heatCapacitor.port.T", "Port temperature [K|degC]", \
"heatCapacitor.T", 1, 1, 6, 4)
DeclareAlias2("heatCapacitor.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", 1, 5, 128, 132)
DeclareParameter("limiter.uMax", "Upper limits of input signals", 44, 200, \
0.0,0.0,0.0,0,560)
DeclareParameter("limiter.uMin", "Lower limits of input signals", 45, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 67, false, 0.0,0.0,0.0,0,515)
DeclareVariable("limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 68, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("limiter.u", "Connector of Real input signal", "PI.y", 1, 5, 127, 0)
DeclareAlias2("limiter.y", "Connector of Real output signal", "signalVoltage.p.v", 1,\
 5, 75, 0)
DeclareAlias2("limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "PI.y", 1, 5, 127, 1024)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preD(DYNX(W_,73),"gearbox.lossyGear.mode", 2, 0);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(F_,4), 0, 1);
DoRemember_(DYNX(W_,95), 0.0, 4);
DoRemember_(DYNX(F_,6), 0, 5);
DoRemember_(DYNX(F_,0), 0.0, 0);
DoRemember_(DYNX(W_,96), 0.0, 2);
DoRemember_(DYNX(W_,115), 0.0, 3);
DoRememAcc_(DYNX(W_,129), 0.0, 6);
EndEqBlock
EndDataBlock
