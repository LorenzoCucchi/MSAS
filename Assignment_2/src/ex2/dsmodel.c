#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Assignment
 Dymola Version 2023 (64-bit), 2022-04-13 translated this at Sat Dec 16 00:07:11 2023

   */

#include <matrixop.h>
#include "matrixop.c"
static double DymArrays5[4]={0.0, 0.5, 1.0, 1.5};
static double DymArrays3[4]={0.0, 50.0, 100.0, 210.0};
static double DymArrays4[4]={0.99, 0.98, 0.97, 0.96};
#if defined(DynSimStruct)
static double DymArrays2[5]={0.99, 0.99, 0.0, 0.0, 0.0};
static double DymArrays0[7]={3.0, 2.0, 1.0, 0.0, -1.0, 1.0, 1.0};
static double DymArrays1[21]={2.0, 0.0, 0.99, 0.99, 0.0, 0.0, 50.0, 0.98, 0.98, 
  0.5, 0.5, 100.0, 0.97, 0.97, 1.0, 1.0, 210.0, 0.96, 0.96, 1.5, 1.5};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#define NX_    6
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    111
#define NWP_   59
#define NP_    28
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -223697593
#define NHash2_ -29897993
#define NHash3_ 0
#define NI_    0
#define NRelF_ 8
#define NRel_  8
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    82
#define SizePre_ 1
#define SizeEq_ 6
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 1
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 43
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Assignment";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[13]={4 , 3 , 1 , 2 , 4 , 1 , 3 , 1 , 5 , 1 , 6 , 0
   , 0};
static int QJacobianGrp0[7]={1, 0, 1, 1, 0, 0, 0};
static int QJacobianGrp1[7]={3, 3, 3, 3, 3, 3, 0};
static int QJacobianGrp2[5]={1, 5 , 1 , 1 , 0};
static int QJacobianGrp3[6]={1, 6 , 2 , 1 , 6 , 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[5]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{1, QJacobianGrp2},{1, QJacobianGrp3},
  {0,0}};
DYMOLA_STATIC double QJacobianCD_[7]={0  , 44 , 55 , 60 , 77 , 72 , 72};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,74) = 0;
DYNX(W_,76) = 0;
DYNX(W_,82) = 288.15;
DYNX(W_,60) = true;
DYNX(W_,61) = false;
DYNX(W_,62) = false;
DYNX(W_,63) = false;
DYNX(W_,64) = 2;
DYNX(F_,2) = 0;
DYNX(F_,3) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,3) = false;
DYNX(W_,6) = false;
DYNX(W_,8) = 3;
DYNX(W_,10) = 3;
DYNX(W_,11) = false;
DYNX(W_,16) = true;
DYNX(W_,38) = true;
memcpy(&DYNX(W_,40), &DymArrays0, sizeof(double)*7);
DYNX(W_,52) = false;
DYNX(W_,53) = false;
DYNX(W_,14) = false;
DYNX(W_,15) = 2;
memcpy(&DYNX(W_,17), &DymArrays1, sizeof(double)*21);
memcpy(&DYNX(W_,47), &DymArrays2, sizeof(double)*5);
DYNX(W_,54) = 1;
DYNX(W_,57) = 1;
DYNX(W_,13) = false;
DYNX(W_,12) = 0;
DYNX(W_,9) = 0;
DYNX(W_,0) = 0;
DYNX(W_,56) = 0;
DYNX(W_,55) = false;
DYNX(W_,7) = 0.0;
DYNX(W_,1) = 0.0;
DYNX(W_,39) = false;
DYNX(W_,2) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,15) >= DYNX(DP_,16),"limiter.uMax >= limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,15), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,16),
   true, 0)),")"));
BoundParameterSection
DYNX(W_,4) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,4)-DYNX(DP_,1)) >= 1E-15,"1+resistor.alpha*(resistor.T_heatPort-resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(DYNhelp,0) = fabs(DYNX(DP_,20));
DYNX(W_,58) = DYNX(DYNhelp,0) < 1E-15;
BoundParameterConstantSection
DYNX(W_,5) = DYNX(DP_,0)*(1+DYNX(DP_,2)*(DYNX(W_,4)-DYNX(DP_,1)));
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(X_,4) = DYNX(DP_,19);
DYNX(X_,5) = DYNX(DP_,22);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,64);
InitialSection
InitialSection2
DYNX(W_,2) = 0.0;
DYNX(X_,2) = 0;
DYNX(X_,5) = DYNX(DP_,22);
DYNX(X_,4) = DYNX(DP_,19);
DYNX(W_,59) = DYNX(DP_,11)+(IF LessTime(DYNX(DP_,12), 0) THEN 0 ELSE 
  DYNX(DP_,10));
DYNX(W_,79) = DYNX(W_,59);
DYNX(W_,110) = DYNX(DP_,27)*DYNX(W_,79);
DYNX(W_,109) = IF DYNX(W_,58) THEN 0 ELSE  -divGuarded(DYNX(DP_,20)*DYNX(X_,5),
  "D.k*D.x",DYNX(DP_,21),"D.T");
DYNX(W_,83) = DYNX(DP_,24)*DYNX(W_,110)+DYNX(DP_,25)*DYNX(X_,4)+DYNX(DP_,26)*
  DYNX(W_,109);
DYNX(W_,65) = homotopy(IF GreaterS(DYNX(W_,83),"limiter.u", DYNX(DP_,15),
  "limiter.uMax", 0) THEN DYNX(DP_,15) ELSE IF LessS(DYNX(W_,83),"limiter.u", 
  DYNX(DP_,16),"limiter.uMin", 1) THEN DYNX(DP_,16) ELSE DYNX(W_,83), 
  DYNX(W_,83));
InitialSection
InitialSection2
DYNX(W_,64) = DYNX(Aux_,0);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,72) = DYNX(DP_,4)*DYNX(X_,0);
DYNX(W_,74) = 2*DYNX(X_,2);
DYNX(DYNhelp,1) = fabs(DYNX(W_,74));
DYNX(W_,87) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0, 50.0, 100.0, 210.0}, {0.99, 0.98, 0.97, 0.96}, noEvent(abs(lossyGear.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays3, 1, 4), 
  RealTemporaryDense( DymArrays4, 1, 4), DYNX(DYNhelp,1), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,88) = DYNX(W_,87);
DYNX(W_,89) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0, 50.0, 100.0, 210.0}, {0.0, 0.5, 1.0, 1.5}, noEvent(abs(lossyGear.w_a)), 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays3, 1, 4), 
  RealTemporaryDense( DymArrays5, 1, 4), DYNX(DYNhelp,1), 1).yi0_0_0member);
PopAllMarks();
DYNX(DYNhelp,2) = fabs(DYNX(W_,89));
DYNX(W_,93) = DYNX(DYNhelp,2);
DYNX(W_,90) = DYNX(W_,89);
DYNX(DYNhelp,3) = fabs(DYNX(W_,90));
DYNX(W_,94) = DYNX(DYNhelp,3);
DYNX(DYNhelp,4) = fabs(DYNX(W_,87)-1.0);
DYNX(DYNhelp,5) = fabs(DYNX(W_,88)-1.0);
DYNX(W_,91) = IF DYNX(DYNhelp,4) <= 1E-15 AND DYNX(DYNhelp,5) <= 1E-15 THEN 
  DYNX(W_,93)/(double)(2) ELSE divGuarded(DYNX(W_,93)-DYNX(W_,94),
  "lossyGear.tau_bf1-lossyGear.tau_bf2",DYNX(W_,87)-divinvGuarded(DYNX(W_,88),
  "lossyGear.eta_mf2"),"lossyGear.eta_mf1-1.0/lossyGear.eta_mf2");
DYNX(W_,78) = DYNX(DP_,8)*(IF GreaterEqualS(DYNX(X_,2),"der(quadraticSpeedDependentTorque.phi)",
   0,"0", 2) THEN sqr(divGuarded(DYNX(X_,2),"der(quadraticSpeedDependentTorque.phi)",
  DYNX(DP_,9),"quadraticSpeedDependentTorque.w_nominal")) ELSE  -sqr(divGuarded(
  DYNX(X_,2),"der(quadraticSpeedDependentTorque.phi)",DYNX(DP_,9),
  "quadraticSpeedDependentTorque.w_nominal")));

MixedSystemOfEquations(19, DYNX(DYNhelp,6))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 13 common subexpressions used in 15 expressions */
  /* Of the common subexpressions 13 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,25) = IF DYNX(W_,60) THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,26) = IF DYNX(W_,63) THEN 0.0 ELSE IF DYNX(W_,61) OR PRE(
    DYNX(W_,64), 0) == 1 THEN 1.0 ELSE 0.0;
  DYNX(DYNhelp,27) = DYNX(DYNhelp,25)*DYNX(DYNhelp,26);
  DYNX(DYNhelp,28) = IF DYNX(W_,63) THEN 0.0 ELSE IF DYNX(W_,61) OR PRE(
    DYNX(W_,64), 0) == 1 THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,29) = DYNX(DYNhelp,25)*DYNX(DYNhelp,28);
  DYNX(DYNhelp,30) = divinvGuarded(DYNX(W_,88),"lossyGear.eta_mf2");
  DYNX(DYNhelp,31) = IF DYNX(W_,60) THEN 0.0 ELSE 1.0;
  DYNX(DYNhelp,32) = DYNX(DYNhelp,31)*DYNX(DYNhelp,28);
  DYNX(DYNhelp,33) = DYNX(DYNhelp,31)*DYNX(DYNhelp,26);
  DYNX(DYNhelp,34) = (DYNX(DYNhelp,30)-1)*DYNX(DYNhelp,29)+(DYNX(W_,87)-1)*
    DYNX(DYNhelp,32)+(DYNX(DYNhelp,30)-1.0)*DYNX(DYNhelp,33)+(DYNX(W_,87)-1.0)*
    DYNX(DYNhelp,27);
  DYNX(DYNhelp,35) = DYNX(DYNhelp,34)*DYNX(W_,78);
  /* Automatic tearing of linear system of 12 simultaneous equations
  gave a linear system of 3 equations for numerical solution.*/
  {
  const char*const varnames_[]={"Propeller.der(w)", "lossyGear.tauLoss", 
    "lossyGear.sa"};
  const double nominal_[]={1.0, 1.0, 1.0};
  DYNX(F_,2)=RememberSimple_(DYNX(F_,2), 0);
  DYNX(W_,103)=RememberSimple_(DYNX(W_,103), 1);
  DYNX(W_,86)=RememberSimple_(DYNX(W_,86), 2);
  SolveLinear3by3(0.5*DYNX(DYNhelp,34)*DYNX(DP_,7), 1.0+DYNX(DYNhelp,34),  -(IF 
    DYNX(W_,63) THEN 1.0 ELSE 0.0), 
  2.0,  -(IF DYNX(W_,63) THEN 0.0 ELSE -1.0),  -(IF DYNX(W_,63) THEN 0.0 ELSE 
    1.0), 
  0.5*DYNX(DP_,7)+2.0*DYNX(DP_,6), 1.0, 0.0, 
  DYNX(DYNhelp,27)*DYNX(W_,93)-(DYNX(DYNhelp,29)*DYNX(W_,94)-0.5*
    DYNX(DYNhelp,35)+DYNX(DYNhelp,32)*DYNX(W_,93))+DYNX(DYNhelp,33)*DYNX(W_,94),
     0.0, 0.5*DYNX(W_,78)-DYNX(W_,72), &DYNX(F_,2), &DYNX(W_,103), &DYNX(W_,86),
     
  varnames_, &MixedFailFlag_, "simulation.linear[1]");
  }
  DYNX(W_,77) = DYNX(DP_,7)*DYNX(F_,2)-DYNX(W_,78);
  DYNX(W_,73) = (-0.5)*(2*DYNX(W_,103)+DYNX(W_,77));
  DYNX(DYNhelp,36) = (1-DYNX(DYNhelp,30))*DYNX(W_,73);
  DYNX(W_,98) =  -(DYNX(DYNhelp,36)+DYNX(W_,94));
  DYNX(DYNhelp,37) = (1-DYNX(W_,87))*DYNX(W_,73);
  DYNX(W_,97) =  -(DYNX(DYNhelp,37)+DYNX(W_,93));
  DYNX(W_,105) = IF DYNX(W_,60) THEN DYNX(W_,98) ELSE DYNX(W_,97);
  DYNX(W_,96) = DYNX(W_,94)-DYNX(DYNhelp,36);
  DYNX(W_,95) = DYNX(W_,93)-DYNX(DYNhelp,37);
  DYNX(W_,104) = IF DYNX(W_,60) THEN DYNX(W_,95) ELSE DYNX(W_,96);
  DYNX(W_,75) = 2*DYNX(F_,2);
   /* End of Equation Block */ 

  DYNX(W_,92) = IF DYNX(W_,63) THEN  -DYNX(W_,73) ELSE IF DYNX(W_,61) OR PRE(
    DYNX(W_,64), 0) == 1 THEN  -(DYNX(W_,73)+DYNX(W_,91)) ELSE DYNX(W_,91)-
    DYNX(W_,73);
  DYNX(W_,101) = (-0.010000000000000009)*DYNX(W_,73);
  DYNX(W_,102) = 0.010101010101010166*DYNX(W_,73);
  DYNX(W_,107) = IF  -DYNX(W_,73) > 0 THEN DYNX(W_,102) ELSE DYNX(W_,101);
  DYNX(W_,100) = 0.010101010101010166*DYNX(W_,73);
  DYNX(W_,99) = (-0.010000000000000009)*DYNX(W_,73);
  DYNX(W_,106) = IF  -DYNX(W_,73) > 0 THEN DYNX(W_,99) ELSE DYNX(W_,100);

  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,60),"lossyGear.tau_etaPos", GreaterEqual(
    DYNX(W_,92),"lossyGear.tau_eta", 0,"0", 3));
  UpdateVariableNamed(DYNX(W_,62),"lossyGear.startBackward", PRE(DYNX(W_,64), 0)
     == 0 AND Less(DYNX(W_,86),"lossyGear.sa", DYNX(W_,107),"lossyGear.tauLossMin_m",
     4) OR initial() AND Less(DYNX(W_,74),"lossyGear.w_a", 0,"0", 5));
  UpdateVariableNamed(DYNX(W_,61),"lossyGear.startForward", PRE(DYNX(W_,64), 0)
     == 0 AND Greater(DYNX(W_,86),"lossyGear.sa", DYNX(W_,106),"lossyGear.tauLossMax_p",
     6) OR initial() AND Greater(DYNX(W_,74),"lossyGear.w_a", 0,"0", 7));
  UpdateVariableNamed(DYNX(W_,63),"lossyGear.locked",  NOT (PRE(DYNX(W_,64), 0)
     == 1 OR DYNX(W_,61) OR PRE(DYNX(W_,64), 0) == -1 OR DYNX(W_,62)));
  MixedModeInit(5, DYNX(DYNhelp,38))
  ThetaMixedCross(0,3)
  ThetaMixedCross(1,4)
  ThetaMixedCross(2,5)
  ThetaMixedCross(3,6)
  ThetaMixedCross(4,7)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,97), 1)
  UpdateReal(DYNX(W_,98), 2)
  UpdateReal(DYNX(W_,105), 3)
  UpdateReal(DYNX(W_,96), 4)
  UpdateReal(DYNX(W_,95), 5)
  UpdateReal(DYNX(W_,92), 6)
  UpdateReal(DYNX(W_,104), 7)
  UpdateReal(DYNX(W_,101), 8)
  UpdateReal(DYNX(W_,102), 9)
  UpdateReal(DYNX(W_,107), 10)
  UpdateReal(DYNX(W_,100), 11)
  UpdateReal(DYNX(W_,99), 12)
  UpdateReal(DYNX(W_,106), 13)
  UpdateReal(DYNX(W_,86), 14)
  UpdateReal(DYNX(W_,103), 15)
  UpdateReal(DYNX(W_,75), 16)
  UpdateReal(DYNX(W_,73), 17)
  UpdateReal(DYNX(W_,77), 18)
  UpdateReal(DYNX(F_,2), 19)
EndMixedSystemOfEquations

DYNX(F_,5) = IF DYNX(W_,58) THEN 0 ELSE divGuarded(DYNX(X_,2)-DYNX(X_,5),
  "der(speedSensor.flange.phi)-D.x",DYNX(DP_,21),"D.T");
DYNX(W_,59) = DYNX(DP_,11)+(IF LessTime(DYNX(DP_,12), 0) THEN 0 ELSE 
  DYNX(DP_,10));
DYNX(W_,79) = DYNX(W_,59)-DYNX(X_,2);
DYNX(F_,4) = DYNX(DP_,18)*DYNX(W_,79);
DYNX(W_,70) = DYNX(DP_,4)*DYNX(W_,74);
DYNX(W_,66) = DYNX(W_,5)*DYNX(X_,0);
DYNX(W_,110) = DYNX(DP_,27)*DYNX(W_,79);
DYNX(W_,109) = IF DYNX(W_,58) THEN 0 ELSE divGuarded(DYNX(DP_,20)*(DYNX(X_,2)-
  DYNX(X_,5)),"D.k*(der(speedSensor.flange.phi)-D.x)",DYNX(DP_,21),"D.T");
DYNX(W_,83) = DYNX(DP_,24)*DYNX(W_,110)+DYNX(DP_,25)*DYNX(X_,4)+DYNX(DP_,26)*
  DYNX(W_,109);
DYNX(W_,65) = IF GreaterS(DYNX(W_,83),"limiter.u", DYNX(DP_,15),"limiter.uMax", 0)
   THEN DYNX(DP_,15) ELSE IF LessS(DYNX(W_,83),"limiter.u", DYNX(DP_,16),
  "limiter.uMin", 1) THEN DYNX(DP_,16) ELSE DYNX(W_,83);
DYNX(W_,67) = DYNX(W_,66)+DYNX(W_,65);
DYNX(W_,69) = DYNX(W_,70)-DYNX(W_,67);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 3);
SolveScalarLinearParametric(DYNX(DP_,3),"inductor.L", DYNX(W_,69),"inductor.v", 
  DYNX(F_,0),"der(inductor.i)");
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(W_,74);
DYNX(W_,80) = DYNX(W_,103)*DYNX(W_,74);
 /* Linear system of equations to solve. */
DYNX(F_,3) = RememberSimple_(DYNX(F_,3), 4);
SolveScalarLinearParametric(DYNX(DP_,14),"heatCapacitor.C", DYNX(W_,80),
  "heatCapacitor.port.Q_flow", DYNX(F_,3),"der(heatCapacitor.T)");
 /* End of Equation Block */ 


AcceptedSection1
DYNX(W_,64) = IF (PRE(DYNX(W_,64), 0) == 1 OR DYNX(W_,61)) AND Greater(
  DYNX(W_,74),"lossyGear.w_a", 0,"0", 7) THEN 1 ELSE IF (PRE(DYNX(W_,64), 0) == -1
   OR DYNX(W_,62)) AND Less(DYNX(W_,74),"lossyGear.w_a", 0,"0", 5) THEN -1 ELSE 0;

AcceptedSection2
DYNX(W_,84) = DYNX(X_,1)-DYNX(DP_,17);
DYNX(W_,85) = 0.5*DYNX(W_,84);
DYNX(W_,76) = DYNX(W_,85)+DYNX(DP_,17);
DYNX(W_,71) = DYNX(X_,1)-DYNX(DP_,5);
DYNX(W_,68) = DYNX(W_,66)*DYNX(X_,0);
 /* Linear system of equations to solve. */
DYNX(W_,81) = RememberSimple_(DYNX(W_,81), 5);
SolveScalarLinearParametric( -DYNX(DP_,13)," -thermalConductor.G",  -DYNX(W_,80),
  " -thermalConductor.Q_flow", DYNX(W_,81),"thermalConductor.dT");
 /* End of Equation Block */ 

DYNX(W_,82) = DYNX(W_,81)+DYNX(X_,3);
DYNX(W_,108) =  -(DYNX(W_,73)+DYNX(W_,77));

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("signalVoltage.p.v", "Potential at the pin [V]", 65, 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("signalVoltage.p.i", "Current flowing into the pin [A]", \
"inductor.i", 1, 1, 0, 132)
DeclareVariable("signalVoltage.n.v", "Potential at the pin [V]", 0, 0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("signalVoltage.n.i", "Current flowing into the pin [A]", \
"inductor.i", -1, 1, 0, 132)
DeclareAlias2("signalVoltage.v", "Voltage between pin p and n (= p.v - n.v) as input signal [V]",\
 "signalVoltage.p.v", 1, 5, 65, 0)
DeclareAlias2("signalVoltage.i", "Current flowing from pin p to pin n [A]", \
"inductor.i", 1, 1, 0, 0)
DeclareVariable("ground.p.v", "Potential at the pin [V]", 1, 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground.p.i", "Current flowing into the pin [A]", 2, 0.0, \
0.0,0.0,0.0,0,777)
DeclareParameter("resistor.R", "Resistance at temperature T_ref [Ohm]", 0, 0.1, \
0.0,0.0,0.0,0,560)
DeclareParameter("resistor.T_ref", "Reference temperature [K|degC]", 1, 300.15, \
0.0,1E+100,300.0,0,560)
DeclareParameter("resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 66,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("resistor.p.v", "Potential at the pin [V]", 67, 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("resistor.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareAlias2("resistor.n.v", "Potential at the pin [V]", "signalVoltage.p.v", 1,\
 5, 65, 4)
DeclareAlias2("resistor.n.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 1, 0, 132)
DeclareAlias2("resistor.i", "Current flowing from pin p to pin n [A]", \
"inductor.i", 1, 1, 0, 0)
DeclareVariable("resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 3, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 4, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 68, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("resistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"resistor.T", 1, 5, 4, 0)
DeclareVariable("resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 5, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 69,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inductor.p.v", "Potential at the pin [V]", 70, 0.0, 0.0,0.0,0.0,\
0,520)
DeclareAlias2("inductor.p.i", "Current flowing into the pin [A]", "inductor.i", 1,\
 1, 0, 132)
DeclareAlias2("inductor.n.v", "Potential at the pin [V]", "resistor.p.v", 1, 5, 67,\
 4)
DeclareAlias2("inductor.n.i", "Current flowing into the pin [A]", "inductor.i", -1,\
 1, 0, 132)
DeclareState("inductor.i", "Current flowing from pin p to pin n [A]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("inductor.L", "Inductance [H]", 3, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 6, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("emf.k", "Transformation coefficient [N.m/A]", 4, 0.3, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("emf.v", "Voltage drop between the two pins [V]", "inductor.p.v", 1,\
 5, 70, 0)
DeclareAlias2("emf.i", "Current flowing from positive to negative pin [A]", \
"inductor.i", -1, 1, 0, 0)
DeclareVariable("emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 71, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "inertia.w", 1, 5, 74, 0)
DeclareAlias2("emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "inertia.w", 1, 5, 74, 0)
DeclareVariable("emf.tau", "Torque of flange [N.m]", 72, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("emf.tauElectrical", "Electrical torque [N.m]", "emf.tau", -1, 5, 72,\
 0)
DeclareAlias2("emf.p.v", "Potential at the pin [V]", "inductor.p.v", 1, 5, 70, 4)
DeclareAlias2("emf.p.i", "Current flowing into the pin [A]", "inductor.i", -1, 1,\
 0, 132)
DeclareVariable("emf.n.v", "Potential at the pin [V]", 7, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("emf.n.i", "Current flowing into the pin [A]", "inductor.i", 1, 1,\
 0, 132)
DeclareAlias2("emf.flange.phi", "Absolute rotation angle of flange [rad|deg]", \
"inertia.phi", 1, 1, 1, 4)
DeclareAlias2("emf.flange.tau", "Cut torque in the flange [N.m]", "emf.tau", 1, 5,\
 72, 132)
DeclareParameter("emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]", 5,\
 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("emf.fixed.flange.tau", "Cut torque in the flange [N.m]", \
"emf.tau", 1, 5, 72, 1156)
DeclareAlias2("emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "emf.tau", -1, 5, 72, 1024)
DeclareAlias2("emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "emf.fixed.phi0", 1, 7, 5, 1024)
DeclareAlias2("emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "emf.tau", -1, 5, 72, 1156)
DeclareAlias2("inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareAlias2("inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"emf.tau", -1, 5, 72, 132)
DeclareAlias2("inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareVariable("inertia.flange_b.tau", "Cut torque in the flange [N.m]", 73, \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("inertia.J", "Moment of inertia [kg.m2]", 6, 0.001, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 8, 3, 1.0,5.0,0.0,0,1541)
DeclareState("inertia.phi", "Absolute rotation angle of component [rad|deg]", 1,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 74, 0, 0.0,0.0,0.0,0,512)
DeclareVariable("inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 75, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "inertia.der(w)", 1, 5, 75, 0)
DeclareVariable("speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 76, 0, 0.0,0.0,0.0,0,520)
DeclareAlias2("speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "Propeller.w", 1, 1, 2, 4)
DeclareVariable("speedSensor.flange.tau", "Cut torque in the flange [N.m]", 9, 0,\
 0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "Propeller.w", 1, 1, 2, 0)
DeclareAlias2("Propeller.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 5, 76, 4)
DeclareVariable("Propeller.flange_a.tau", "Cut torque in the flange [N.m]", 77, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("Propeller.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 5, 76, 4)
DeclareVariable("Propeller.flange_b.tau", "Cut torque in the flange [N.m]", 78, \
0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("Propeller.J", "Moment of inertia [kg.m2]", 7, 0.0535, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("Propeller.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 10, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("Propeller.phi", "Absolute rotation angle of component [rad|deg]",\
 "speedSensor.flange.phi", 1, 5, 76, 0)
DeclareAlias2("Propeller.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "Propeller.w", 1, 1, 2, 0)
DeclareState("Propeller.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("Propeller.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 2, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Propeller.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "Propeller.der(w)", 1, 6, 2, 0)
DeclareVariable("quadraticSpeedDependentTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 11, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("quadraticSpeedDependentTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 5, 76, 4)
DeclareAlias2("quadraticSpeedDependentTorque.flange.tau", "Cut torque in the flange [N.m]",\
 "Propeller.flange_b.tau", -1, 5, 78, 132)
DeclareVariable("quadraticSpeedDependentTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 12, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("quadraticSpeedDependentTorque.phi", "Angle of flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "speedSensor.flange.phi", 1, 5, 76, 0)
DeclareAlias2("quadraticSpeedDependentTorque.der(phi)", "der(Angle of flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "Propeller.w", 1, 1, 2, 0)
DeclareParameter("quadraticSpeedDependentTorque.tau_nominal", "Nominal torque (if negative, torque is acting as load in positive direction of rotation) [N.m]",\
 8, -100, 0.0,0.0,0.0,0,560)
DeclareVariable("quadraticSpeedDependentTorque.TorqueDirection", \
"Same direction of torque in both directions of rotation [:#(type=Boolean)]", 13,\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("quadraticSpeedDependentTorque.w_nominal", "Nominal speed [rad/s]",\
 9, 210, 1E-15,1E+100,0.0,0,560)
DeclareAlias2("quadraticSpeedDependentTorque.w", "Angular velocity of flange with respect to support (= der(phi)) [rad/s]",\
 "Propeller.w", 1, 1, 2, 0)
DeclareAlias2("quadraticSpeedDependentTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "Propeller.flange_b.tau", 1, 5, 78, 0)
DeclareParameter("step.height", "Height of step [rad/s]", 10, 210, 0.0,0.0,0.0,0,560)
DeclareVariable("step.y", "Connector of Real output signal [rad/s]", 59, 0.0, \
0.0,0.0,0.0,0,640)
DeclareParameter("step.offset", "Offset of output signal y [rad/s]", 11, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 12, 5, 0.0,0.0,0.0,0,560)
DeclareAlias2("feedback.u1", "Commanded input [rad/s]", "step.y", 1, 5, 59, 0)
DeclareAlias2("feedback.u2", "Feedback input [rad/s]", "Propeller.w", 1, 1, 2, 0)
DeclareVariable("feedback.y", "[rad/s]", 79, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("thermalConductor.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 80, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("thermalConductor.dT", "port_a.T - port_b.T [K,]", 81, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("thermalConductor.port_a.T", "Port temperature [K|degC]", 82, \
288.15, 0.0,1E+100,300.0,0,520)
DeclareAlias2("thermalConductor.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", 1, 5, 80, 132)
DeclareAlias2("thermalConductor.port_b.T", "Port temperature [K|degC]", \
"heatCapacitor.T", 1, 1, 3, 4)
DeclareAlias2("thermalConductor.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", -1, 5, 80, 132)
DeclareParameter("thermalConductor.G", "Constant thermal conductance of material [W/K]",\
 13, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("heatCapacitor.C", "Heat capacity of element (= cp*m) [J/K]", 14,\
 3000, 0.0,0.0,0.0,0,560)
DeclareState("heatCapacitor.T", "Temperature of element [K|degC]", 3, 293.15, \
0.0,1E+100,300.0,0,560)
DeclareDerivative("heatCapacitor.der(T)", "der(Temperature of element) [K/s]", 3,\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("heatCapacitor.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "heatCapacitor.der(T)", 1, 6, 3, 0)
DeclareAlias2("heatCapacitor.port.T", "Port temperature [K|degC]", \
"heatCapacitor.T", 1, 1, 3, 4)
DeclareAlias2("heatCapacitor.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", 1, 5, 80, 132)
DeclareParameter("limiter.uMax", "Upper limits of input signals", 15, 200, \
0.0,0.0,0.0,0,560)
DeclareParameter("limiter.uMin", "Lower limits of input signals", 16, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 14, false, 0.0,0.0,0.0,0,515)
DeclareVariable("limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 15, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("limiter.u", "Connector of Real input signal", 83, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("limiter.y", "Connector of Real output signal [V]", \
"signalVoltage.p.v", 1, 5, 65, 0)
DeclareAlias2("limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "limiter.u", 1, 5, 83, 1024)
DeclareVariable("lossyGear.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 16, true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("lossyGear.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "inertia.phi", 1, 1, 1, 4)
DeclareAlias2("lossyGear.flange_a.tau", "Cut torque in the flange [N.m]", \
"inertia.flange_b.tau", -1, 5, 73, 132)
DeclareAlias2("lossyGear.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "speedSensor.flange.phi", 1, 5, 76, 4)
DeclareAlias2("lossyGear.flange_b.tau", "Cut torque in the flange [N.m]", \
"Propeller.flange_a.tau", -1, 5, 77, 132)
DeclareAlias2("lossyGear.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 "fixed.phi0", 1, 7, 17, 4)
DeclareAlias2("lossyGear.support.tau", "Cut torque in the flange [N.m]", \
"fixed.flange.tau", -1, 5, 108, 132)
DeclareAlias2("lossyGear.phi_support", "Absolute angle of support flange [rad|deg]",\
 "fixed.phi0", 1, 7, 17, 1024)
DeclareVariable("lossyGear.ratio", "Transmission ratio (flange_a.phi/flange_b.phi) [1]",\
 17, 2, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[1, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 18, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[1, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 19, 0.99, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[1, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 20, 0.99, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[1, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 21, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[1, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 22, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[2, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 23, 50.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[2, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 24, 0.98, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[2, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 25, 0.98, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[2, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 26, 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[2, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 27, 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[3, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 28, 100.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[3, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 29, 0.97, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[3, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 30, 0.97, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[3, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 31, 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[3, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 32, 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[4, 1]", "Array for mesh efficiencies and bearing friction depending on speed",\
 33, 210.0, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[4, 2]", "Array for mesh efficiencies and bearing friction depending on speed",\
 34, 0.96, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[4, 3]", "Array for mesh efficiencies and bearing friction depending on speed",\
 35, 0.96, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[4, 4]", "Array for mesh efficiencies and bearing friction depending on speed",\
 36, 1.5, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.lossTable[4, 5]", "Array for mesh efficiencies and bearing friction depending on speed",\
 37, 1.5, 0.0,0.0,0.0,0,513)
DeclareVariable("lossyGear.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 38, true, 0.0,0.0,0.0,0,1539)
DeclareAlias2("lossyGear.heatPort.T", "Port temperature [K|degC]", \
"thermalConductor.port_a.T", 1, 5, 82, 4)
DeclareAlias2("lossyGear.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "thermalConductor.Q_flow", -1, 5, 80, 132)
DeclareAlias2("lossyGear.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "thermalConductor.Q_flow", 1, 5, 80, 0)
DeclareVariable("lossyGear.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 84, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("lossyGear.der(phi_a)", "der(Angle between left shaft flange and support) [rad/s]",\
 "inertia.w", 1, 5, 74, 0)
DeclareVariable("lossyGear.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 85, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.sa", "Path parameter for acceleration and torque loss [1]",\
 86, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("lossyGear.w_a", "Angular velocity of flange_a with respect to support [rad/s]",\
 "inertia.w", 1, 5, 74, 0)
DeclareAlias2("lossyGear.der(w_a)", "der(Angular velocity of flange_a with respect to support) [rad/s2]",\
 "inertia.der(w)", 1, 5, 75, 0)
DeclareAlias2("lossyGear.a_a", "Angular acceleration of flange_a with respect to support [rad/s2]",\
 "inertia.der(w)", 1, 5, 75, 0)
DeclareVariable("lossyGear.interpolation_result[1, 1]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 87, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.interpolation_result[1, 2]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 88, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.interpolation_result[1, 3]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 89, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.interpolation_result[1, 4]", "Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])",\
 90, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("lossyGear.eta_mf1", "Mesh efficiency in case that flange_a is driving [1]",\
 "lossyGear.interpolation_result[1, 1]", 1, 5, 87, 0)
DeclareAlias2("lossyGear.eta_mf2", "Mesh efficiency in case that flange_b is driving [1]",\
 "lossyGear.interpolation_result[1, 2]", 1, 5, 88, 0)
DeclareVariable("lossyGear.tau_bf_a", "Bearing friction torque on flange_a side [N.m]",\
 91, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tau_eta", "Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau) [N.m]",\
 92, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tau_bf1", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving (= |tau_bf_a*eta_mf1 + tau_bf_b/i|) [N.m]",\
 93, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tau_bf2", "Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving (= |tau_bf_a/eta_mf2 + tau_bf_b/i|) [N.m]",\
 94, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant1", "Torque loss if w_a > 0 and flange_a.tau >= 0 [N.m]",\
 95, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant2", "Torque loss if w_a > 0 and flange_a.tau < 0 [N.m]",\
 96, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant3", "Torque loss if w_a < 0 and flange_a.tau >= 0 [N.m]",\
 97, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant4", "Torque loss if w_a < 0 and flange_a.tau < 0 [N.m]",\
 98, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant1_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau >= 0) [N.m]",\
 99, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant2_p", "Torque loss at w_a = 0+ to determine driving side (flange_a.tau < 0) [N.m]",\
 100, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant3_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau >=0) [N.m]",\
 101, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.quadrant4_m", "Torque loss at w_a = 0- to determine driving side (flange_a.tau < 0) [N.m]",\
 102, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tauLoss", "Torque loss due to friction in the gear teeth and in the bearings [N.m]",\
 103, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tauLossMax", "Torque loss for positive speed [N.m]", 104,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tauLossMin", "Torque loss for negative speed [N.m]", 105,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tauLossMax_p", "Torque loss for positive speed [N.m]",\
 106, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tauLossMin_m", "Torque loss for negative speed [N.m]",\
 107, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("lossyGear.tau_aPos", "Only for backwards compatibility (was previously: true, if torque of flange_a is not negative) [:#(type=Boolean)]",\
 60, true, 0.0,0.0,0.0,0,706)
DeclareAlias2("lossyGear.tau_etaPos", "= true, if torque tau_eta is not negative [:#(type=Boolean)]",\
 "lossyGear.tau_aPos", 1, 5, 60, 65)
DeclareVariable("lossyGear.startForward", "= true, if starting to roll forward [:#(type=Boolean)]",\
 61, false, 0.0,0.0,0.0,0,706)
DeclareVariable("lossyGear.startBackward", "= true, if starting to roll backward [:#(type=Boolean)]",\
 62, false, 0.0,0.0,0.0,0,706)
DeclareVariable("lossyGear.locked", "= true, if gear is locked [:#(type=Boolean)]",\
 63, false, 0.0,0.0,0.0,0,706)
DeclareVariable("lossyGear.ideal", "= true, if losses are neglected (that is lossTable = [0, 1, 1, 0, 0]) [:#(type=Boolean)]",\
 39, false, 0.0,0.0,0.0,0,515)
DeclareVariable("lossyGear.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 40, 3, 0.0,0.0,0.0,0,517)
DeclareVariable("lossyGear.Free", "Element is not active [:#(type=Integer)]", 41,\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("lossyGear.Forward", "w_a > 0 (forward rolling) [:#(type=Integer)]",\
 42, 1, 0.0,0.0,0.0,0,517)
DeclareVariable("lossyGear.Stuck", "w_a = 0 (forward rolling, locked or backward rolling) [:#(type=Integer)]",\
 43, 0, 0.0,0.0,0.0,0,517)
DeclareVariable("lossyGear.Backward", "w_a < 0 (backward rolling) [:#(type=Integer)]",\
 44, -1, 0.0,0.0,0.0,0,517)
DeclareVariable("lossyGear.mode", "Mode of friction element (unknown, not active, forward/backward rolling, stuck) [:#(type=Integer)]",\
 64, 2, -1.0,3.0,0.0,0,660)
DeclareAlias2("lossyGear.tau_eta_p", "tau_eta assuming positive omega [N.m]", \
"inertia.flange_b.tau", -1, 5, 73, 0)
DeclareAlias2("lossyGear.tau_eta_m", "tau_eta assuming negative omega [N.m]", \
"inertia.flange_b.tau", -1, 5, 73, 0)
DeclareVariable("lossyGear.unitAngularAcceleration", "[rad/s2]", 45, 1, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("lossyGear.unitTorque", "[N.m]", 46, 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("lossyGear.eta_mf1_0", "[1]", 47, 0.99, 0.0,0.0,0.0,0,2561)
DeclareVariable("lossyGear.eta_mf2_0", "[1]", 48, 0.99, 0.0,0.0,0.0,0,2561)
DeclareVariable("lossyGear.tau_bf1_0", "[N.m]", 49, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("lossyGear.tau_bf2_0", "[N.m]", 50, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("lossyGear.tau_bf_a_0", "[N.m]", 51, 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("fixed.phi0", "Fixed offset angle of housing [rad|deg]", 17, 0,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "fixed.phi0", 1, 7, 17, 4)
DeclareVariable("fixed.flange.tau", "Cut torque in the flange [N.m]", 108, 0.0, \
0.0,0.0,0.0,0,776)
DeclareParameter("I.k", "Integrator gain [1]", 18, 7.0, 0.0,0.0,0.0,0,560)
DeclareVariable("I.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 52, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("I.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 53, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 54, 1, 1.0,4.0,0.0,0,517)
DeclareParameter("I.y_start", "Initial or guess value of output (= state) [rad]",\
 19, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("I.u", "Connector of Real input signal [rad/s]", "feedback.y", 1, 5,\
 79, 0)
DeclareState("I.y", "Connector of Real output signal [rad]", 4, 0.0, 0.0,0.0,0.0,\
0,544)
DeclareDerivative("I.der(y)", "der(Connector of Real output signal) [rad/s]", 4,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("I.local_reset", "[:#(type=Boolean)]", 55, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("I.local_set", "", 56, 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("D.k", "Gains [1]", 20, 0.017, 0.0,0.0,0.0,0,560)
DeclareParameter("D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 21, 0.00017, 1E-60,1E+100,0.0,0,560)
DeclareVariable("D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 57, 1, 1.0,4.0,0.0,0,517)
DeclareParameter("D.x_start", "Initial or guess value of state [rad/s]", 22, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("D.y_start", "Initial value of output (= state) [rad/s2]", 23, 0,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("D.u", "Connector of Real input signal [rad/s]", "Propeller.w", 1,\
 1, 2, 0)
DeclareVariable("D.y", "Connector of Real output signal [rad/s2]", 109, 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("D.x", "State of block [rad/s]", 5, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("D.der(x)", "der(State of block) [rad/s2]", 5, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("D.zeroGain", "[:#(type=Boolean)]", 58, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Add.k1", "Gain of input signal 1", 24, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("Add.k2", "Gain of input signal 2", 25, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("Add.k3", "Gain of input signal 3", 26, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("Add.u1", "Connector of Real input signal 1 [rad/s]", 110, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("Add.u2", "Connector of Real input signal 2 [rad]", "I.y", 1, 1, 4,\
 0)
DeclareAlias2("Add.u3", "Connector of Real input signal 3 [rad/s2]", "D.y", 1, 5,\
 109, 0)
DeclareAlias2("Add.y", "Connector of Real output signal", "limiter.u", 1, 5, 83,\
 0)
DeclareParameter("P1.k", "Gain value multiplied with input signal [1]", 27, 0.15,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("P1.u", "Input signal connector [rad/s]", "feedback.y", 1, 5, 79, 0)
DeclareAlias2("P1.y", "Output signal connector [rad/s]", "Add.u1", 1, 5, 110, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preD(DYNX(W_,64),"lossyGear.mode", 2, 0);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(F_,2), 0, 0);
DoRemember_(DYNX(F_,3), 0, 4);
DoRemember_(DYNX(F_,0), 0.0, 3);
DoRemember_(DYNX(W_,86), 0.0, 2);
DoRemember_(DYNX(W_,103), 0.0, 1);
DoRememAcc_(DYNX(W_,81), 0.0, 5);
EndEqBlock
EndDataBlock
