#1
char Aclass(3,24)
Adymosim
1.4
Modelica experiment file


#    Experiment parameters
double experiment(7,1)
       0                   # StartTime    Time at which integration starts
                           #              (and linearization and trimming time)
     120                   # StopTime     Time at which integration stops
       0                   # Increment    Communication step size, if > 0
   12000                   # nInterval    Number of communication intervals, if > 0
  9.9999999999999998E-13   # Tolerance    Relative precision of signals for
                           #              simulation, linearization and trimming
       0                   # MaxFixedStep Maximum step size of fixed step size
                           #              integrators, if > 0.0
      17                   # Algorithm    Integration algorithm as integer (1...28)
                           #
                           #             | model|       |        | dense | state |
                           # Algorithm   | typ  | stiff | order  | output| event |
                           # ------------+------+-------+--------+-------+-------+
                           #  1 | deabm  |  ode |   no  |  1-12  |  yes  |   no  |
                           #  2 | lsode1 |  ode |   no  |  1-12  |  yes  |   no  |
                           #  3 | lsode2 |  ode |  yes  |  1-5   |  yes  |   no  |
                           #  4 | lsodar |  ode |  both |1-12,1-5|  yes  |  yes  |
                           #  5 | dopri5 |  ode |   no  |   5    |   no  |   no  |
                           #  6 | dopri8 |  ode |   no  |   8    |   no  |   no  |
                           #  7 | grk4t  |  ode |  yes  |   4    |   no  |   no  |
                           #  8 | dassl  |  dae |  yes  |  1-5   |  yes  |  yes  |
                           #  9 | odassl | hdae |  yes  |  1-5   |  yes  |  yes  |
                           # 10 | mexx   | hdae |   no  |  2-24  |   no  |   no  |
                           # 11 | euler  |  ode |   no  |   1    |   no  |  yes  |
                           # 12 | rkfix2 |  ode |   no  |   2    |   no  |  yes  |
                           # 13 | rkfix3 |  ode |   no  |   3    |   no  |  yes  |
                           # 14 | rkfix4 |  ode |   no  |   4    |   no  |  yes  |
                           #>=14| others |  ode |yes/no |  2-5   |   yes |  yes  |
                           # ---+--------+------+-------+--------+-------+-------+
                           # euler and rkfix have fixed stepsize.


#    Method tuning parameters
double method(27,1)
       1                   # grid     type of communication time grid, defined by
                           #          = 1: equidistant points ("Increment/nInterval")
                           #          = 2: vector of grid points ("tgrid")
                           #          = 3: variable step integrator (automatically)
                           #          = 4: model (call of "increment" in Dymola, e.g.
                           #                      incr=Time > 2 then 0 else 0.1
                           #                      dummy=increment(incr))
                           #          grid = 1,3 is stopped by "StopTime"
                           #          grid = 2   is stopped by "tgrid(last)"
                           #          grid = 4   runs forever (stopped by model)
       1                   # nt       Use every NT time instant, if grid = 3
       3                   # dense    1/2/3 restart/step/interpolate GRID points
       1                   # evgrid   0/1 do not/save event points in comm. time grid
       1                   # evu      0/1 U-discontinuity does not/trigger events
       0                   # evuord       U-discontinuity order to consider (0,1,...)
       0                   # error    0/1/2 One message/warning/error messages
       0                   # jac      0/1 Compute jacobian numerically/by BLOCKJ
       0                   # xd0c     0/1 Compute/set XD0
       0                   # f3       0/1 Ignore/use F3 of HDAE (= index 1)
       0                   # f4       0/1 Ignore/use F4 of HDAE (= index 2)
       0                   # f5       0/1 Ignore/use F5 of HDAE (= invar.)
       0                   # debug    flags for debug information (1<<0 uses pdebug) 
     100                   # pdebug       priority of debug information (1...100)
       0                   # fmax     Maximum number of evaluations of BLOCKF, if > 0
       0                   # ordmax   Maximum allowed integration order, if > 0
       0                   # hmax     Maximum absolute stepsize, if > 0
       0                   # hmin     Minimum absolute stepsize, if > 0 (use with care!)
       0                   # h0       Stepsize to be attempted on first step, if > 0
  2.0000000000000000E-14   # teps     Bound to check, if 2 equal time instants
  1.0000000000000000E-10   # eveps    Hysteresis epsilon at event points
      20                   # eviter   Maximum number of event iterations
  9.9999999999999995E-07   # delaym   Minimum time increment in delay buffers
       1                   # fexcep   0/1 floating exception crashes/stops dymosim
       1                   # tscale   clock-time = tscale*simulation-time, if grid = 5
                           #          > 1: simulation too slow
                           #          = 1: simulation-time = real-time
                           #          < 1: simulation too fast
       1                   # shared   (not used)
    2473                   # memkey   (not used)


#    Output parameters
int settings(13,1)
 0                         # lprec    0/1 do not/store result data in double
 1                         # lx       0/1 do not/store x  (state variables)
 1                         # lxd      0/1 do not/store xd (derivative of states)
 1                         # lu       0/1 do not/store u  (input     signals)
 1                         # ly       0/1 do not/store y  (output    signals)
 0                         # lz       0/1 do not/store z  (indicator signals)
 1                         # lw       0/1 do not/store w  (auxiliary signals)
 1                         # la       0/1 do not/store a  (alias     signals)
 0                         # lperf    0/1 do not/store performance indicators
 0                         # levent   0/1 do not/store event point
 1                         # lres     0/1 do not/store results on result file
 0                         # lshare   0/1 do not/store info data for shared memory on dsshare.txt
 1                         # lform    0/1 ASCII/Matlab-binary storage format of results
                           #              (for simulation/linearization; not for trimming)


#    Names of initial variables
char initialName(151,45)
signalVoltage.p.v
signalVoltage.n.v
ground.p.v
ground.p.i
resistor.R
resistor.T_ref
resistor.alpha
resistor.v
resistor.p.v
resistor.useHeatPort
resistor.T
resistor.LossPower
resistor.R_actual
inductor.v
inductor.p.v
inductor.i
inductor.der(i)
inductor.L
emf.useSupport
emf.k
emf.phi
emf.tau
emf.n.v
emf.fixed.phi0
inertia.flange_b.tau
inertia.J
inertia.stateSelect
inertia.phi
inertia.der(phi)
inertia.w
inertia.der(w)
speedSensor.flange.phi
speedSensor.flange.tau
Propeller.flange_a.tau
Propeller.flange_b.tau
Propeller.J
Propeller.stateSelect
Propeller.w
Propeller.der(w)
quadraticSpeedDependentTorque.useSupport
quadraticSpeedDependentTorque.phi_support
quadraticSpeedDependentTorque.tau_nominal
quadraticSpeedDependentTorque.TorqueDirection
quadraticSpeedDependentTorque.w_nominal
step.height
step.y
step.offset
step.startTime
feedback.y
thermalConductor.Q_flow
thermalConductor.dT
thermalConductor.port_a.T
thermalConductor.G
heatCapacitor.C
heatCapacitor.T
heatCapacitor.der(T)
limiter.uMax
limiter.uMin
limiter.strict
limiter.homotopyType
limiter.u
lossyGear.useSupport
lossyGear.ratio
lossyGear.lossTable[1, 1]
lossyGear.lossTable[1, 2]
lossyGear.lossTable[1, 3]
lossyGear.lossTable[1, 4]
lossyGear.lossTable[1, 5]
lossyGear.lossTable[2, 1]
lossyGear.lossTable[2, 2]
lossyGear.lossTable[2, 3]
lossyGear.lossTable[2, 4]
lossyGear.lossTable[2, 5]
lossyGear.lossTable[3, 1]
lossyGear.lossTable[3, 2]
lossyGear.lossTable[3, 3]
lossyGear.lossTable[3, 4]
lossyGear.lossTable[3, 5]
lossyGear.lossTable[4, 1]
lossyGear.lossTable[4, 2]
lossyGear.lossTable[4, 3]
lossyGear.lossTable[4, 4]
lossyGear.lossTable[4, 5]
lossyGear.useHeatPort
lossyGear.phi_a
lossyGear.phi_b
lossyGear.sa
lossyGear.interpolation_result[1, 1]
lossyGear.interpolation_result[1, 2]
lossyGear.interpolation_result[1, 3]
lossyGear.interpolation_result[1, 4]
lossyGear.tau_bf_a
lossyGear.tau_eta
lossyGear.tau_bf1
lossyGear.tau_bf2
lossyGear.quadrant1
lossyGear.quadrant2
lossyGear.quadrant3
lossyGear.quadrant4
lossyGear.quadrant1_p
lossyGear.quadrant2_p
lossyGear.quadrant3_m
lossyGear.quadrant4_m
lossyGear.tauLoss
lossyGear.tauLossMax
lossyGear.tauLossMin
lossyGear.tauLossMax_p
lossyGear.tauLossMin_m
lossyGear.tau_aPos
lossyGear.startForward
lossyGear.startBackward
lossyGear.locked
lossyGear.ideal
lossyGear.Unknown
lossyGear.Free
lossyGear.Forward
lossyGear.Stuck
lossyGear.Backward
lossyGear.mode
lossyGear.unitAngularAcceleration
lossyGear.unitTorque
lossyGear.eta_mf1_0
lossyGear.eta_mf2_0
lossyGear.tau_bf1_0
lossyGear.tau_bf2_0
lossyGear.tau_bf_a_0
fixed.phi0
fixed.flange.tau
I.k
I.use_reset
I.use_set
I.initType
I.y_start
I.y
I.der(y)
I.local_reset
I.local_set
D.k
D.T
D.initType
D.x_start
D.y_start
D.y
D.x
D.der(x)
D.zeroGain
Add.k1
Add.k2
Add.k3
Add.u1
P1.k

double initialValue(151,6)
  0       0                       0                       0                
  6   260   # signalVoltage.p.v
  0       0                       0                       0                
  6   260   # signalVoltage.n.v
  0       0                       0                       0                
  6   260   # ground.p.v
  0       0                       0                       0                
  6   388   # ground.p.i
 -1  1.0000000000000001E-01       0                       0                
  1   280   # resistor.R
 -1  3.0014999999999998E+02       0                 1.0000000000000000E+100
  1   280   # resistor.T_ref
 -1       0                       0                       0                
  1   280   # resistor.alpha
  0       0                       0                       0                
  6   256   # resistor.v
  0       0                       0                       0                
  6   260   # resistor.p.v
  0       0                       0                       0                
  6   769   # resistor.useHeatPort
  0  2.8814999999999998E+02       0                 1.0000000000000000E+100
  6   256   # resistor.T
  0       0                       0                       0                
  6   256   # resistor.LossPower
  0       0                       0                       0                
  6   256   # resistor.R_actual
  0       0                       0                       0                
  6   256   # inductor.v
  0       0                       0                       0                
  6   260   # inductor.p.v
 -1       0                       0                       0                
  2   280   # inductor.i
  0       0                       0                       0                
  3   256   # inductor.der(i)
 -1  1.0000000000000000E-02       0                       0                
  1   280   # inductor.L
  0       0                       0                       0                
  6   769   # emf.useSupport
 -1  2.9999999999999999E-01       0                       0                
  1   280   # emf.k
  0       0                       0                       0                
  6   256   # emf.phi
  0       0                       0                       0                
  6   256   # emf.tau
  0       0                       0                       0                
  6   260   # emf.n.v
 -1       0                       0                       0                
  1  1304   # emf.fixed.phi0
  0       0                       0                       0                
  6   388   # inertia.flange_b.tau
 -1  1.0000000000000000E-03       0                 1.0000000000000000E+100
  1   280   # inertia.J
  0       3                       1                       5                
  6   770   # inertia.stateSelect
 -1       0                       0                       0                
  2   280   # inertia.phi
  0       0                       0                       0                
  3   256   # inertia.der(phi)
  0       0                       0                       0                
  6   256   # inertia.w
  0       0                       0                       0                
  6   256   # inertia.der(w)
  0       0                       0                       0                
  6   260   # speedSensor.flange.phi
  0       0                       0                       0                
  6   388   # speedSensor.flange.tau
  0       0                       0                       0                
  6   388   # Propeller.flange_a.tau
  0       0                       0                       0                
  6   388   # Propeller.flange_b.tau
 -1  5.3499999999999999E-02       0                 1.0000000000000000E+100
  1   280   # Propeller.J
  0       3                       1                       5                
  6   770   # Propeller.stateSelect
 -1       0                       0                       0                
  2   272   # Propeller.w
  0       0                       0                       0                
  3   256   # Propeller.der(w)
  0       0                       0                       0                
  6   769   # quadraticSpeedDependentTorque.useSupport
  0       0                       0                       0                
  6  1280   # quadraticSpeedDependentTorque.phi_support
 -1    -100                       0                       0                
  1   280   # quadraticSpeedDependentTorque.tau_nominal
  0       0                       0                       0                
  6   257   # quadraticSpeedDependentTorque.TorqueDirection
 -1     210                  1.0000000000000001E-15 1.0000000000000000E+100
  1   280   # quadraticSpeedDependentTorque.w_nominal
 -1     210                       0                       0                
  1   280   # step.height
  0       0                       0                       0                
  6   320   # step.y
 -1       0                       0                       0                
  1   280   # step.offset
 -1       5                       0                       0                
  1   280   # step.startTime
  0       0                       0                       0                
  6   256   # feedback.y
  0       0                       0                       0                
  6   256   # thermalConductor.Q_flow
  0       0                       0                       0                
  6   256   # thermalConductor.dT
  0  2.8814999999999998E+02       0                 1.0000000000000000E+100
  6   260   # thermalConductor.port_a.T
 -1     100                       0                       0                
  1   280   # thermalConductor.G
 -1    3000                       0                       0                
  1   280   # heatCapacitor.C
 -1  2.9314999999999998E+02       0                 1.0000000000000000E+100
  2   280   # heatCapacitor.T
  0       0                       0                       0                
  3   256   # heatCapacitor.der(T)
 -1     200                       0                       0                
  1   280   # limiter.uMax
 -1       0                       0                       0                
  1   280   # limiter.uMin
  0       0                       0                       0                
  6   257   # limiter.strict
  0       2                       1                       4                
  6   258   # limiter.homotopyType
  0       0                       0                       0                
  6   256   # limiter.u
  0       1                       0                       0                
  6   769   # lossyGear.useSupport
  0       2                       0                       0                
  6   256   # lossyGear.ratio
  0       0                       0                       0                
  6   256   # lossyGear.lossTable[1, 1]
  0  9.8999999999999999E-01       0                       0                
  6   256   # lossyGear.lossTable[1, 2]
  0  9.8999999999999999E-01       0                       0                
  6   256   # lossyGear.lossTable[1, 3]
  0       0                       0                       0                
  6   256   # lossyGear.lossTable[1, 4]
  0       0                       0                       0                
  6   256   # lossyGear.lossTable[1, 5]
  0      50                       0                       0                
  6   256   # lossyGear.lossTable[2, 1]
  0  9.7999999999999998E-01       0                       0                
  6   256   # lossyGear.lossTable[2, 2]
  0  9.7999999999999998E-01       0                       0                
  6   256   # lossyGear.lossTable[2, 3]
  0  5.0000000000000000E-01       0                       0                
  6   256   # lossyGear.lossTable[2, 4]
  0  5.0000000000000000E-01       0                       0                
  6   256   # lossyGear.lossTable[2, 5]
  0     100                       0                       0                
  6   256   # lossyGear.lossTable[3, 1]
  0  9.6999999999999997E-01       0                       0                
  6   256   # lossyGear.lossTable[3, 2]
  0  9.6999999999999997E-01       0                       0                
  6   256   # lossyGear.lossTable[3, 3]
  0       1                       0                       0                
  6   256   # lossyGear.lossTable[3, 4]
  0       1                       0                       0                
  6   256   # lossyGear.lossTable[3, 5]
  0     210                       0                       0                
  6   256   # lossyGear.lossTable[4, 1]
  0  9.5999999999999996E-01       0                       0                
  6   256   # lossyGear.lossTable[4, 2]
  0  9.5999999999999996E-01       0                       0                
  6   256   # lossyGear.lossTable[4, 3]
  0  1.5000000000000000E+00       0                       0                
  6   256   # lossyGear.lossTable[4, 4]
  0  1.5000000000000000E+00       0                       0                
  6   256   # lossyGear.lossTable[4, 5]
  0       1                       0                       0                
  6   769   # lossyGear.useHeatPort
  0       0                       0                       0                
  6   256   # lossyGear.phi_a
  0       0                       0                       0                
  6   256   # lossyGear.phi_b
  0       0                       0                       0                
  6   256   # lossyGear.sa
  0       0                       0                       0                
  6   256   # lossyGear.interpolation_result[1, 1]
  0       0                       0                       0                
  6   256   # lossyGear.interpolation_result[1, 2]
  0       0                       0                       0                
  6   256   # lossyGear.interpolation_result[1, 3]
  0       0                       0                       0                
  6   256   # lossyGear.interpolation_result[1, 4]
  0       0                       0                       0                
  6   256   # lossyGear.tau_bf_a
  0       0                       0                       0                
  6   256   # lossyGear.tau_eta
  0       0                       0                       0                
  6   256   # lossyGear.tau_bf1
  0       0                       0                       0                
  6   256   # lossyGear.tau_bf2
  0       0                       0                       0                
  6   256   # lossyGear.quadrant1
  0       0                       0                       0                
  6   256   # lossyGear.quadrant2
  0       0                       0                       0                
  6   256   # lossyGear.quadrant3
  0       0                       0                       0                
  6   256   # lossyGear.quadrant4
  0       0                       0                       0                
  6   256   # lossyGear.quadrant1_p
  0       0                       0                       0                
  6   256   # lossyGear.quadrant2_p
  0       0                       0                       0                
  6   256   # lossyGear.quadrant3_m
  0       0                       0                       0                
  6   256   # lossyGear.quadrant4_m
  0       0                       0                       0                
  6   256   # lossyGear.tauLoss
  0       0                       0                       0                
  6   256   # lossyGear.tauLossMax
  0       0                       0                       0                
  6   256   # lossyGear.tauLossMin
  0       0                       0                       0                
  6   256   # lossyGear.tauLossMax_p
  0       0                       0                       0                
  6   256   # lossyGear.tauLossMin_m
  0       1                       0                       0                
  6   353   # lossyGear.tau_aPos
  0       0                       0                       0                
  6   353   # lossyGear.startForward
  0       0                       0                       0                
  6   353   # lossyGear.startBackward
  0       0                       0                       0                
  6   353   # lossyGear.locked
  0       0                       0                       0                
  6   257   # lossyGear.ideal
  0       3                       0                       0                
  6   258   # lossyGear.Unknown
  0       2                       0                       0                
  6   258   # lossyGear.Free
  0       1                       0                       0                
  6   258   # lossyGear.Forward
  0       0                       0                       0                
  6   258   # lossyGear.Stuck
  0      -1                       0                       0                
  6   258   # lossyGear.Backward
  0       2                      -1                       3                
  6   330   # lossyGear.mode
  0       1                       0                       0                
  6  1280   # lossyGear.unitAngularAcceleration
  0       1                       0                       0                
  6  1280   # lossyGear.unitTorque
  0  9.8999999999999999E-01       0                       0                
  6  1280   # lossyGear.eta_mf1_0
  0  9.8999999999999999E-01       0                       0                
  6  1280   # lossyGear.eta_mf2_0
  0       0                       0                       0                
  6  1280   # lossyGear.tau_bf1_0
  0       0                       0                       0                
  6  1280   # lossyGear.tau_bf2_0
  0       0                       0                       0                
  6  1280   # lossyGear.tau_bf_a_0
 -1       0                       0                       0                
  1   280   # fixed.phi0
  0       0                       0                       0                
  6   388   # fixed.flange.tau
 -1       7                       0                       0                
  1   280   # I.k
  0       0                       0                       0                
  6   769   # I.use_reset
  0       0                       0                       0                
  6   769   # I.use_set
  0       1                       1                       4                
  6   258   # I.initType
 -1       0                       0                       0                
  1   280   # I.y_start
 -1       0                       0                       0                
  2   272   # I.y
  0       0                       0                       0                
  3   256   # I.der(y)
  0       0                       0                       0                
  6   769   # I.local_reset
  0       0                       0                       0                
  6   768   # I.local_set
 -1  1.7000000000000001E-02       0                       0                
  1   280   # D.k
 -1  1.7000000000000001E-04  9.9999999999999997E-61 1.0000000000000000E+100
  1   280   # D.T
  0       1                       1                       4                
  6   258   # D.initType
 -1       0                       0                       0                
  1   280   # D.x_start
 -1       0                       0                       0                
  1   280   # D.y_start
  0       0                       0                       0                
  6   256   # D.y
 -1       0                       0                       0                
  2   272   # D.x
  0       0                       0                       0                
  3   256   # D.der(x)
  0       0                       0                       0                
  6  1281   # D.zeroGain
 -1       1                       0                       0                
  1   280   # Add.k1
 -1       1                       0                       0                
  1   280   # Add.k2
 -1      -1                       0                       0                
  1   280   # Add.k3
  0       0                       0                       0                
  6   256   # Add.u1
 -1  1.4999999999999999E-01       0                       0                
  1   280   # P1.k


# Matrix with 6 columns defining the initial value calculation
# (columns 5 and 6 are not utilized for the calculation but are
#  reported by dymosim via dymosim -i for user convenience):
#
# column 1: Type of initial value
#           = -2: special case: for continuing simulation (column 2 = value)
#           = -1: fixed value (column 2 = fixed value)
#           =  0: free value, i.e., no restriction (column 2 = initial value)
#           >  0: desired value (column 1 = weight for optimization
#                                column 2 = desired value)
#                 use weight=1, since automatic scaling usually
#                 leads to equally weighted terms
# column 2: fixed, free or desired value according to column 1.
# column 3: Minimum value (ignored, if Minimum >= Maximum).
# column 4: Maximum value (ignored, if Minimum >= Maximum).
#           Minimum and maximum restrict the search range in initial
#           value calculation. They might also be used for scaling.
# column 5: Category of variable.
#           = 1: parameter.
#           = 2: state.
#           = 3: state derivative.
#           = 4: output.
#           = 5: input.
#           = 6: auxiliary variable.
# column 6: Data type of variable and flags according to dsBaseType
#  <value>&3= 0: real.
#  <value>&3= 1: boolean.
#  <value>&3= 2: integer.
#
# Initial values are calculated according to the following procedure:
#
# Initial values are calculated according to the following procedure:
#
# - If parameters, states and inputs are FIXED, and other variables
#   are FREE, the initialization is performed in the normal way.
#
# - If parameters and inputs are FIXED, and all other variables
#   have special case for continue (-2 in 1st column), or FREE
#   the initialization is ignored and variables are set to these values.
#   This is intended to continue the simulation.
#
#   Which variables will be important for initialization and continue
#   is indicated by value in column 6 & dsStartMasks.
#
char initialDescription(151,163)
Potential at the pin [V]
Potential at the pin [V]
Potential at the pin [V]
Current flowing into the pin [A]
Resistance at temperature T_ref [Ohm]
Reference temperature [K|degC]
Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]
Voltage drop of the two pins (= p.v - n.v) [V]
Potential at the pin [V]
= true, if heatPort is enabled [:#(type=Boolean)]
Fixed device temperature if useHeatPort = false [K|degC]
Loss power leaving component via heatPort [W]
Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]
Voltage drop of the two pins (= p.v - n.v) [V]
Potential at the pin [V]
Current flowing from pin p to pin n [A]
der(Current flowing from pin p to pin n) [A/s]
Inductance [H]
= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]
Transformation coefficient [N.m/A]
Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]
Torque of flange [N.m]
Potential at the pin [V]
Fixed offset angle of housing [rad|deg]
Cut torque in the flange [N.m]
Moment of inertia [kg.m2]
Priority to use phi and w as states [:#(type=StateSelect)]
Absolute rotation angle of component [rad|deg]
der(Absolute rotation angle of component) [rad/s]
Absolute angular velocity of component (= der(phi)) [rad/s]
der(Absolute angular velocity of component (= der(phi))) [rad/s2]
Absolute rotation angle of flange [rad|deg]
Cut torque in the flange [N.m]
Cut torque in the flange [N.m]
Cut torque in the flange [N.m]
Moment of inertia [kg.m2]
Priority to use phi and w as states [:#(type=StateSelect)]
Absolute angular velocity of component (= der(phi)) [rad/s]
der(Absolute angular velocity of component (= der(phi))) [rad/s2]
= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]
Absolute angle of support flange [rad|deg]
Nominal torque (if negative, torque is acting as load in positive direction of rotation) [N.m]
Same direction of torque in both directions of rotation [:#(type=Boolean)]
Nominal speed [rad/s]
Height of step [rad/s]
Connector of Real output signal [rad/s]
Offset of output signal y [rad/s]
Output y = offset for time < startTime [s]
[rad/s]
Heat flow rate from port_a -> port_b [W]
port_a.T - port_b.T [K,]
Port temperature [K|degC]
Constant thermal conductance of material [W/K]
Heat capacity of element (= cp*m) [J/K]
Temperature of element [K|degC]
der(Temperature of element) [K/s]
Upper limits of input signals
Lower limits of input signals
= true, if strict limits with noEvent(..) [:#(type=Boolean)]
Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]
Connector of Real input signal
= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]
Transmission ratio (flange_a.phi/flange_b.phi) [1]
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
Array for mesh efficiencies and bearing friction depending on speed
= true, if heatPort is enabled [:#(type=Boolean)]
Angle between left shaft flange and support [rad|deg]
Angle between right shaft flange and support [rad|deg]
Path parameter for acceleration and torque loss [1]
Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])
Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])
Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])
Result of interpolation in lossTable (= [eta_mf1, eta_mf2, tau_bf1, tau_bf2])
Bearing friction torque on flange_a side [N.m]
Torque that determines the driving side (= if forwardSliding then flange_a.tau-tau_bf_a else if backwardSliding then flange_a.tau+tau_bf_a else flange_a.tau) [N.m]
Absolute resultant bearing friction torque with respect to flange_a in case that flange_a is driving (= |tau_bf_a*eta_mf1 + tau_bf_b/i|) [N.m]
Absolute resultant bearing friction torque with respect to flange_a in case that flange_b is driving (= |tau_bf_a/eta_mf2 + tau_bf_b/i|) [N.m]
Torque loss if w_a > 0 and flange_a.tau >= 0 [N.m]
Torque loss if w_a > 0 and flange_a.tau < 0 [N.m]
Torque loss if w_a < 0 and flange_a.tau >= 0 [N.m]
Torque loss if w_a < 0 and flange_a.tau < 0 [N.m]
Torque loss at w_a = 0+ to determine driving side (flange_a.tau >= 0) [N.m]
Torque loss at w_a = 0+ to determine driving side (flange_a.tau < 0) [N.m]
Torque loss at w_a = 0- to determine driving side (flange_a.tau >=0) [N.m]
Torque loss at w_a = 0- to determine driving side (flange_a.tau < 0) [N.m]
Torque loss due to friction in the gear teeth and in the bearings [N.m]
Torque loss for positive speed [N.m]
Torque loss for negative speed [N.m]
Torque loss for positive speed [N.m]
Torque loss for negative speed [N.m]
Only for backwards compatibility (was previously: true, if torque of flange_a is not negative) [:#(type=Boolean)]
= true, if starting to roll forward [:#(type=Boolean)]
= true, if starting to roll backward [:#(type=Boolean)]
= true, if gear is locked [:#(type=Boolean)]
= true, if losses are neglected (that is lossTable = [0, 1, 1, 0, 0]) [:#(type=Boolean)]
Value of mode is not known [:#(type=Integer)]
Element is not active [:#(type=Integer)]
w_a > 0 (forward rolling) [:#(type=Integer)]
w_a = 0 (forward rolling, locked or backward rolling) [:#(type=Integer)]
w_a < 0 (backward rolling) [:#(type=Integer)]
Mode of friction element (unknown, not active, forward/backward rolling, stuck) [:#(type=Integer)]
[rad/s2]
[N.m]
[1]
[1]
[N.m]
[N.m]
[N.m]
Fixed offset angle of housing [rad|deg]
Cut torque in the flange [N.m]
Integrator gain [1]
= true, if reset port enabled [:#(type=Boolean)]
= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]
Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]
Initial or guess value of output (= state) [rad]
Connector of Real output signal [rad]
der(Connector of Real output signal) [rad/s]
[:#(type=Boolean)]

Gains [1]
Time constants (T>0 required; T=0 is ideal derivative block) [s]
Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]
Initial or guess value of state [rad/s]
Initial value of output (= state) [rad/s2]
Connector of Real output signal [rad/s2]
State of block [rad/s]
der(State of block) [rad/s2]
[:#(type=Boolean)]
Gain of input signal 1
Gain of input signal 2
Gain of input signal 3
Connector of Real input signal 1 [rad/s]
Gain value multiplied with input signal [1]

